{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='triggerTemplate', url='', help='TriggerTemplate is the template that describes trigger specification.'),
  '#argoWorkflow':: d.obj(help=''),
  argoWorkflow: {
    '#groupVersionResource':: d.obj(help='+protobuf.options.(gogoproto.goproto_stringer)=false'),
    groupVersionResource: {
      '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
      withGroup(group): { argoWorkflow+: { groupVersionResource+: { group: group } } },
      '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
      withResource(resource): { argoWorkflow+: { groupVersionResource+: { resource: resource } } },
      '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
      withVersion(version): { argoWorkflow+: { groupVersionResource+: { version: version } } },
    },
    '#source':: d.obj(help=''),
    source: {
      '#configmap':: d.obj(help='Selects a key from a ConfigMap.'),
      configmap: {
        '#withKey':: d.fn(help='The key to select.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { argoWorkflow+: { source+: { configmap+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { argoWorkflow+: { source+: { configmap+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the ConfigMap or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { argoWorkflow+: { source+: { configmap+: { optional: optional } } } },
      },
      '#file':: d.obj(help=''),
      file: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { argoWorkflow+: { source+: { file+: { path: path } } } },
      },
      '#git':: d.obj(help=''),
      git: {
        '#creds':: d.obj(help=''),
        creds: {
          '#password':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
          password: {
            '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { argoWorkflow+: { source+: { git+: { creds+: { password+: { key: key } } } } } },
            '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { argoWorkflow+: { source+: { git+: { creds+: { password+: { name: name } } } } } },
            '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { argoWorkflow+: { source+: { git+: { creds+: { password+: { optional: optional } } } } } },
          },
          '#username':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
          username: {
            '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { argoWorkflow+: { source+: { git+: { creds+: { username+: { key: key } } } } } },
            '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { argoWorkflow+: { source+: { git+: { creds+: { username+: { name: name } } } } } },
            '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { argoWorkflow+: { source+: { git+: { creds+: { username+: { optional: optional } } } } } },
          },
        },
        '#remote':: d.obj(help=''),
        remote: {
          '#withName':: d.fn(help='Name of the remote to fetch from.', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { argoWorkflow+: { source+: { git+: { remote+: { name: name } } } } },
          '#withUrls':: d.fn(help='URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.', args=[d.arg(name='urls', type=d.T.array)]),
          withUrls(urls): { argoWorkflow+: { source+: { git+: { remote+: { urls: if std.isArray(v=urls) then urls else [urls] } } } } },
          '#withUrlsMixin':: d.fn(help='URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='urls', type=d.T.array)]),
          withUrlsMixin(urls): { argoWorkflow+: { source+: { git+: { remote+: { urls+: if std.isArray(v=urls) then urls else [urls] } } } } },
        },
        '#sshKeySecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        sshKeySecret: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { argoWorkflow+: { source+: { git+: { sshKeySecret+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { argoWorkflow+: { source+: { git+: { sshKeySecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { argoWorkflow+: { source+: { git+: { sshKeySecret+: { optional: optional } } } } },
        },
        '#withBranch':: d.fn(help='', args=[d.arg(name='branch', type=d.T.string)]),
        withBranch(branch): { argoWorkflow+: { source+: { git+: { branch: branch } } } },
        '#withCloneDirectory':: d.fn(help="Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.\nHence we don't use any specific git provider client.", args=[d.arg(name='cloneDirectory', type=d.T.string)]),
        withCloneDirectory(cloneDirectory): { argoWorkflow+: { source+: { git+: { cloneDirectory: cloneDirectory } } } },
        '#withFilePath':: d.fn(help='', args=[d.arg(name='filePath', type=d.T.string)]),
        withFilePath(filePath): { argoWorkflow+: { source+: { git+: { filePath: filePath } } } },
        '#withRef':: d.fn(help='', args=[d.arg(name='ref', type=d.T.string)]),
        withRef(ref): { argoWorkflow+: { source+: { git+: { ref: ref } } } },
        '#withSshKeyPath':: d.fn(help='', args=[d.arg(name='sshKeyPath', type=d.T.string)]),
        withSshKeyPath(sshKeyPath): { argoWorkflow+: { source+: { git+: { sshKeyPath: sshKeyPath } } } },
        '#withTag':: d.fn(help='', args=[d.arg(name='tag', type=d.T.string)]),
        withTag(tag): { argoWorkflow+: { source+: { git+: { tag: tag } } } },
        '#withUrl':: d.fn(help='', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { argoWorkflow+: { source+: { git+: { url: url } } } },
      },
      '#resource':: d.obj(help='Resource represent arbitrary structured data.'),
      resource: {
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { argoWorkflow+: { source+: { resource+: { value: value } } } },
      },
      '#s3':: d.obj(help=''),
      s3: {
        '#accessKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        accessKey: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { argoWorkflow+: { source+: { s3+: { accessKey+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { argoWorkflow+: { source+: { s3+: { accessKey+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { argoWorkflow+: { source+: { s3+: { accessKey+: { optional: optional } } } } },
        },
        '#bucket':: d.obj(help=''),
        bucket: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { argoWorkflow+: { source+: { s3+: { bucket+: { key: key } } } } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { argoWorkflow+: { source+: { s3+: { bucket+: { name: name } } } } },
        },
        '#filter':: d.obj(help=''),
        filter: {
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { argoWorkflow+: { source+: { s3+: { filter+: { prefix: prefix } } } } },
          '#withSuffix':: d.fn(help='', args=[d.arg(name='suffix', type=d.T.string)]),
          withSuffix(suffix): { argoWorkflow+: { source+: { s3+: { filter+: { suffix: suffix } } } } },
        },
        '#secretKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        secretKey: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { argoWorkflow+: { source+: { s3+: { secretKey+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { argoWorkflow+: { source+: { s3+: { secretKey+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { argoWorkflow+: { source+: { s3+: { secretKey+: { optional: optional } } } } },
        },
        '#withEndpoint':: d.fn(help='', args=[d.arg(name='endpoint', type=d.T.string)]),
        withEndpoint(endpoint): { argoWorkflow+: { source+: { s3+: { endpoint: endpoint } } } },
        '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
        withEvents(events): { argoWorkflow+: { source+: { s3+: { events: if std.isArray(v=events) then events else [events] } } } },
        '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
        withEventsMixin(events): { argoWorkflow+: { source+: { s3+: { events+: if std.isArray(v=events) then events else [events] } } } },
        '#withInsecure':: d.fn(help='', args=[d.arg(name='insecure', type=d.T.boolean)]),
        withInsecure(insecure): { argoWorkflow+: { source+: { s3+: { insecure: insecure } } } },
        '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
        withMetadata(metadata): { argoWorkflow+: { source+: { s3+: { metadata: metadata } } } },
        '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
        withMetadataMixin(metadata): { argoWorkflow+: { source+: { s3+: { metadata+: metadata } } } },
        '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
        withRegion(region): { argoWorkflow+: { source+: { s3+: { region: region } } } },
      },
      '#url':: d.obj(help='URLArtifact contains information about an artifact at an http endpoint.'),
      url: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { argoWorkflow+: { source+: { url+: { path: path } } } },
        '#withVerifyCert':: d.fn(help='', args=[d.arg(name='verifyCert', type=d.T.boolean)]),
        withVerifyCert(verifyCert): { argoWorkflow+: { source+: { url+: { verifyCert: verifyCert } } } },
      },
      '#withInline':: d.fn(help='', args=[d.arg(name='inline', type=d.T.string)]),
      withInline(inline): { argoWorkflow+: { source+: { inline: inline } } },
    },
    '#withOperation':: d.fn(help='', args=[d.arg(name='operation', type=d.T.string)]),
    withOperation(operation): { argoWorkflow+: { operation: operation } },
    '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { argoWorkflow+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { argoWorkflow+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
  },
  '#awsLambda':: d.obj(help=''),
  awsLambda: {
    '#accessKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    accessKey: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { awsLambda+: { accessKey+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { awsLambda+: { accessKey+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { awsLambda+: { accessKey+: { optional: optional } } },
    },
    '#secretKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    secretKey: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { awsLambda+: { secretKey+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { awsLambda+: { secretKey+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { awsLambda+: { secretKey+: { optional: optional } } },
    },
    '#withFunctionName':: d.fn(help='FunctionName refers to the name of the function to invoke.', args=[d.arg(name='functionName', type=d.T.string)]),
    withFunctionName(functionName): { awsLambda+: { functionName: functionName } },
    '#withInvocationType':: d.fn(help="Choose from the following options.\n\n   * RequestResponse (default) - Invoke the function synchronously. Keep\n   the connection open until the function returns a response or times out.\n   The API response includes the function response and additional data.\n\n   * Event - Invoke the function asynchronously. Send events that fail multiple\n   times to the function's dead-letter queue (if it's configured). The API\n   response only includes a status code.\n\n   * DryRun - Validate parameter values and verify that the user or role\n   has permission to invoke the function.\n+optional", args=[d.arg(name='invocationType', type=d.T.string)]),
    withInvocationType(invocationType): { awsLambda+: { invocationType: invocationType } },
    '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { awsLambda+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { awsLambda+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPayload':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { awsLambda+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { awsLambda+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
    '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
    withRegion(region): { awsLambda+: { region: region } },
  },
  '#azureEventHubs':: d.obj(help=''),
  azureEventHubs: {
    '#sharedAccessKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    sharedAccessKey: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { azureEventHubs+: { sharedAccessKey+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { azureEventHubs+: { sharedAccessKey+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { azureEventHubs+: { sharedAccessKey+: { optional: optional } } },
    },
    '#sharedAccessKeyName':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    sharedAccessKeyName: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { azureEventHubs+: { sharedAccessKeyName+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { azureEventHubs+: { sharedAccessKeyName+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { azureEventHubs+: { sharedAccessKeyName+: { optional: optional } } },
    },
    '#withFqdn':: d.fn(help='', args=[d.arg(name='fqdn', type=d.T.string)]),
    withFqdn(fqdn): { azureEventHubs+: { fqdn: fqdn } },
    '#withHubName':: d.fn(help='', args=[d.arg(name='hubName', type=d.T.string)]),
    withHubName(hubName): { azureEventHubs+: { hubName: hubName } },
    '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { azureEventHubs+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { azureEventHubs+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPayload':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { azureEventHubs+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { azureEventHubs+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
  },
  '#custom':: d.obj(help='CustomTrigger refers to the specification of the custom trigger.'),
  custom: {
    '#certSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    certSecret: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { custom+: { certSecret+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { custom+: { certSecret+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { custom+: { certSecret+: { optional: optional } } },
    },
    '#withCertFilePath':: d.fn(help='', args=[d.arg(name='certFilePath', type=d.T.string)]),
    withCertFilePath(certFilePath): { custom+: { certFilePath: certFilePath } },
    '#withParameters':: d.fn(help='Parameters is the list of parameters that is applied to resolved custom trigger trigger object.', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { custom+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='Parameters is the list of parameters that is applied to resolved custom trigger trigger object.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { custom+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPayload':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { custom+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { custom+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
    '#withSecure':: d.fn(help='', args=[d.arg(name='secure', type=d.T.boolean)]),
    withSecure(secure): { custom+: { secure: secure } },
    '#withServerNameOverride':: d.fn(help='ServerNameOverride for the secure connection between sensor and custom trigger gRPC server.', args=[d.arg(name='serverNameOverride', type=d.T.string)]),
    withServerNameOverride(serverNameOverride): { custom+: { serverNameOverride: serverNameOverride } },
    '#withServerURL':: d.fn(help='', args=[d.arg(name='serverURL', type=d.T.string)]),
    withServerURL(serverURL): { custom+: { serverURL: serverURL } },
    '#withSpec':: d.fn(help='Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret.', args=[d.arg(name='spec', type=d.T.object)]),
    withSpec(spec): { custom+: { spec: spec } },
    '#withSpecMixin':: d.fn(help='Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='spec', type=d.T.object)]),
    withSpecMixin(spec): { custom+: { spec+: spec } },
  },
  '#http':: d.obj(help=''),
  http: {
    '#basicAuth':: d.obj(help=''),
    basicAuth: {
      '#password':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      password: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { http+: { basicAuth+: { password+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { http+: { basicAuth+: { password+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { http+: { basicAuth+: { password+: { optional: optional } } } },
      },
      '#username':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      username: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { http+: { basicAuth+: { username+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { http+: { basicAuth+: { username+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { http+: { basicAuth+: { username+: { optional: optional } } } },
      },
    },
    '#tls':: d.obj(help='TLSConfig refers to TLS configuration for a client.'),
    tls: {
      '#caCertSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      caCertSecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { http+: { tls+: { caCertSecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { http+: { tls+: { caCertSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { http+: { tls+: { caCertSecret+: { optional: optional } } } },
      },
      '#clientCertSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      clientCertSecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { http+: { tls+: { clientCertSecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { http+: { tls+: { clientCertSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { http+: { tls+: { clientCertSecret+: { optional: optional } } } },
      },
      '#clientKeySecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      clientKeySecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { http+: { tls+: { clientKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { http+: { tls+: { clientKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { http+: { tls+: { clientKeySecret+: { optional: optional } } } },
      },
      '#withCaCertPath':: d.fn(help='', args=[d.arg(name='caCertPath', type=d.T.string)]),
      withCaCertPath(caCertPath): { http+: { tls+: { caCertPath: caCertPath } } },
      '#withClientCertPath':: d.fn(help='', args=[d.arg(name='clientCertPath', type=d.T.string)]),
      withClientCertPath(clientCertPath): { http+: { tls+: { clientCertPath: clientCertPath } } },
      '#withClientKeyPath':: d.fn(help='', args=[d.arg(name='clientKeyPath', type=d.T.string)]),
      withClientKeyPath(clientKeyPath): { http+: { tls+: { clientKeyPath: clientKeyPath } } },
    },
    '#withHeaders':: d.fn(help='', args=[d.arg(name='headers', type=d.T.object)]),
    withHeaders(headers): { http+: { headers: headers } },
    '#withHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.object)]),
    withHeadersMixin(headers): { http+: { headers+: headers } },
    '#withMethod':: d.fn(help='', args=[d.arg(name='method', type=d.T.string)]),
    withMethod(method): { http+: { method: method } },
    '#withParameters':: d.fn(help="Parameters is the list of key-value extracted from event's payload that are applied to\nthe HTTP trigger resource.", args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { http+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help="Parameters is the list of key-value extracted from event's payload that are applied to\nthe HTTP trigger resource.\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { http+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPayload':: d.fn(help='', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { http+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { http+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
    '#withSecureHeaders':: d.fn(help='', args=[d.arg(name='secureHeaders', type=d.T.array)]),
    withSecureHeaders(secureHeaders): { http+: { secureHeaders: if std.isArray(v=secureHeaders) then secureHeaders else [secureHeaders] } },
    '#withSecureHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='secureHeaders', type=d.T.array)]),
    withSecureHeadersMixin(secureHeaders): { http+: { secureHeaders+: if std.isArray(v=secureHeaders) then secureHeaders else [secureHeaders] } },
    '#withTimeout':: d.fn(help='', args=[d.arg(name='timeout', type=d.T.string)]),
    withTimeout(timeout): { http+: { timeout: timeout } },
    '#withUrl':: d.fn(help='URL refers to the URL to send HTTP request to.', args=[d.arg(name='url', type=d.T.string)]),
    withUrl(url): { http+: { url: url } },
  },
  '#k8s':: d.obj(help=''),
  k8s: {
    '#groupVersionResource':: d.obj(help='+protobuf.options.(gogoproto.goproto_stringer)=false'),
    groupVersionResource: {
      '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
      withGroup(group): { k8s+: { groupVersionResource+: { group: group } } },
      '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
      withResource(resource): { k8s+: { groupVersionResource+: { resource: resource } } },
      '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
      withVersion(version): { k8s+: { groupVersionResource+: { version: version } } },
    },
    '#source':: d.obj(help=''),
    source: {
      '#configmap':: d.obj(help='Selects a key from a ConfigMap.'),
      configmap: {
        '#withKey':: d.fn(help='The key to select.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { k8s+: { source+: { configmap+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { k8s+: { source+: { configmap+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the ConfigMap or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { k8s+: { source+: { configmap+: { optional: optional } } } },
      },
      '#file':: d.obj(help=''),
      file: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { k8s+: { source+: { file+: { path: path } } } },
      },
      '#git':: d.obj(help=''),
      git: {
        '#creds':: d.obj(help=''),
        creds: {
          '#password':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
          password: {
            '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { k8s+: { source+: { git+: { creds+: { password+: { key: key } } } } } },
            '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { k8s+: { source+: { git+: { creds+: { password+: { name: name } } } } } },
            '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { k8s+: { source+: { git+: { creds+: { password+: { optional: optional } } } } } },
          },
          '#username':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
          username: {
            '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { k8s+: { source+: { git+: { creds+: { username+: { key: key } } } } } },
            '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { k8s+: { source+: { git+: { creds+: { username+: { name: name } } } } } },
            '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { k8s+: { source+: { git+: { creds+: { username+: { optional: optional } } } } } },
          },
        },
        '#remote':: d.obj(help=''),
        remote: {
          '#withName':: d.fn(help='Name of the remote to fetch from.', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { k8s+: { source+: { git+: { remote+: { name: name } } } } },
          '#withUrls':: d.fn(help='URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.', args=[d.arg(name='urls', type=d.T.array)]),
          withUrls(urls): { k8s+: { source+: { git+: { remote+: { urls: if std.isArray(v=urls) then urls else [urls] } } } } },
          '#withUrlsMixin':: d.fn(help='URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='urls', type=d.T.array)]),
          withUrlsMixin(urls): { k8s+: { source+: { git+: { remote+: { urls+: if std.isArray(v=urls) then urls else [urls] } } } } },
        },
        '#sshKeySecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        sshKeySecret: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { k8s+: { source+: { git+: { sshKeySecret+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { k8s+: { source+: { git+: { sshKeySecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { k8s+: { source+: { git+: { sshKeySecret+: { optional: optional } } } } },
        },
        '#withBranch':: d.fn(help='', args=[d.arg(name='branch', type=d.T.string)]),
        withBranch(branch): { k8s+: { source+: { git+: { branch: branch } } } },
        '#withCloneDirectory':: d.fn(help="Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.\nHence we don't use any specific git provider client.", args=[d.arg(name='cloneDirectory', type=d.T.string)]),
        withCloneDirectory(cloneDirectory): { k8s+: { source+: { git+: { cloneDirectory: cloneDirectory } } } },
        '#withFilePath':: d.fn(help='', args=[d.arg(name='filePath', type=d.T.string)]),
        withFilePath(filePath): { k8s+: { source+: { git+: { filePath: filePath } } } },
        '#withRef':: d.fn(help='', args=[d.arg(name='ref', type=d.T.string)]),
        withRef(ref): { k8s+: { source+: { git+: { ref: ref } } } },
        '#withSshKeyPath':: d.fn(help='', args=[d.arg(name='sshKeyPath', type=d.T.string)]),
        withSshKeyPath(sshKeyPath): { k8s+: { source+: { git+: { sshKeyPath: sshKeyPath } } } },
        '#withTag':: d.fn(help='', args=[d.arg(name='tag', type=d.T.string)]),
        withTag(tag): { k8s+: { source+: { git+: { tag: tag } } } },
        '#withUrl':: d.fn(help='', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { k8s+: { source+: { git+: { url: url } } } },
      },
      '#resource':: d.obj(help='Resource represent arbitrary structured data.'),
      resource: {
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { k8s+: { source+: { resource+: { value: value } } } },
      },
      '#s3':: d.obj(help=''),
      s3: {
        '#accessKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        accessKey: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { k8s+: { source+: { s3+: { accessKey+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { k8s+: { source+: { s3+: { accessKey+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { k8s+: { source+: { s3+: { accessKey+: { optional: optional } } } } },
        },
        '#bucket':: d.obj(help=''),
        bucket: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { k8s+: { source+: { s3+: { bucket+: { key: key } } } } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { k8s+: { source+: { s3+: { bucket+: { name: name } } } } },
        },
        '#filter':: d.obj(help=''),
        filter: {
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { k8s+: { source+: { s3+: { filter+: { prefix: prefix } } } } },
          '#withSuffix':: d.fn(help='', args=[d.arg(name='suffix', type=d.T.string)]),
          withSuffix(suffix): { k8s+: { source+: { s3+: { filter+: { suffix: suffix } } } } },
        },
        '#secretKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        secretKey: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { k8s+: { source+: { s3+: { secretKey+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { k8s+: { source+: { s3+: { secretKey+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { k8s+: { source+: { s3+: { secretKey+: { optional: optional } } } } },
        },
        '#withEndpoint':: d.fn(help='', args=[d.arg(name='endpoint', type=d.T.string)]),
        withEndpoint(endpoint): { k8s+: { source+: { s3+: { endpoint: endpoint } } } },
        '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
        withEvents(events): { k8s+: { source+: { s3+: { events: if std.isArray(v=events) then events else [events] } } } },
        '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
        withEventsMixin(events): { k8s+: { source+: { s3+: { events+: if std.isArray(v=events) then events else [events] } } } },
        '#withInsecure':: d.fn(help='', args=[d.arg(name='insecure', type=d.T.boolean)]),
        withInsecure(insecure): { k8s+: { source+: { s3+: { insecure: insecure } } } },
        '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
        withMetadata(metadata): { k8s+: { source+: { s3+: { metadata: metadata } } } },
        '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
        withMetadataMixin(metadata): { k8s+: { source+: { s3+: { metadata+: metadata } } } },
        '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
        withRegion(region): { k8s+: { source+: { s3+: { region: region } } } },
      },
      '#url':: d.obj(help='URLArtifact contains information about an artifact at an http endpoint.'),
      url: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { k8s+: { source+: { url+: { path: path } } } },
        '#withVerifyCert':: d.fn(help='', args=[d.arg(name='verifyCert', type=d.T.boolean)]),
        withVerifyCert(verifyCert): { k8s+: { source+: { url+: { verifyCert: verifyCert } } } },
      },
      '#withInline':: d.fn(help='', args=[d.arg(name='inline', type=d.T.string)]),
      withInline(inline): { k8s+: { source+: { inline: inline } } },
    },
    '#withLiveObject':: d.fn(help='', args=[d.arg(name='liveObject', type=d.T.boolean)]),
    withLiveObject(liveObject): { k8s+: { liveObject: liveObject } },
    '#withOperation':: d.fn(help='', args=[d.arg(name='operation', type=d.T.string)]),
    withOperation(operation): { k8s+: { operation: operation } },
    '#withParameters':: d.fn(help='Parameters is the list of parameters that is applied to resolved K8s trigger object.', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { k8s+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='Parameters is the list of parameters that is applied to resolved K8s trigger object.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { k8s+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPatchStrategy':: d.fn(help='', args=[d.arg(name='patchStrategy', type=d.T.string)]),
    withPatchStrategy(patchStrategy): { k8s+: { patchStrategy: patchStrategy } },
  },
  '#kafka':: d.obj(help='KafkaTrigger refers to the specification of the Kafka trigger.'),
  kafka: {
    '#sasl':: d.obj(help=''),
    sasl: {
      '#password':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      password: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { kafka+: { sasl+: { password+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { kafka+: { sasl+: { password+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { kafka+: { sasl+: { password+: { optional: optional } } } },
      },
      '#user':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      user: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { kafka+: { sasl+: { user+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { kafka+: { sasl+: { user+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { kafka+: { sasl+: { user+: { optional: optional } } } },
      },
      '#withMechanism':: d.fn(help='', args=[d.arg(name='mechanism', type=d.T.string)]),
      withMechanism(mechanism): { kafka+: { sasl+: { mechanism: mechanism } } },
    },
    '#tls':: d.obj(help='TLSConfig refers to TLS configuration for a client.'),
    tls: {
      '#caCertSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      caCertSecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { kafka+: { tls+: { caCertSecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { kafka+: { tls+: { caCertSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { kafka+: { tls+: { caCertSecret+: { optional: optional } } } },
      },
      '#clientCertSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      clientCertSecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { kafka+: { tls+: { clientCertSecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { kafka+: { tls+: { clientCertSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { kafka+: { tls+: { clientCertSecret+: { optional: optional } } } },
      },
      '#clientKeySecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      clientKeySecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { kafka+: { tls+: { clientKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { kafka+: { tls+: { clientKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { kafka+: { tls+: { clientKeySecret+: { optional: optional } } } },
      },
      '#withCaCertPath':: d.fn(help='', args=[d.arg(name='caCertPath', type=d.T.string)]),
      withCaCertPath(caCertPath): { kafka+: { tls+: { caCertPath: caCertPath } } },
      '#withClientCertPath':: d.fn(help='', args=[d.arg(name='clientCertPath', type=d.T.string)]),
      withClientCertPath(clientCertPath): { kafka+: { tls+: { clientCertPath: clientCertPath } } },
      '#withClientKeyPath':: d.fn(help='', args=[d.arg(name='clientKeyPath', type=d.T.string)]),
      withClientKeyPath(clientKeyPath): { kafka+: { tls+: { clientKeyPath: clientKeyPath } } },
    },
    '#withCompress':: d.fn(help='', args=[d.arg(name='compress', type=d.T.boolean)]),
    withCompress(compress): { kafka+: { compress: compress } },
    '#withFlushFrequency':: d.fn(help='', args=[d.arg(name='flushFrequency', type=d.T.integer)]),
    withFlushFrequency(flushFrequency): { kafka+: { flushFrequency: flushFrequency } },
    '#withParameters':: d.fn(help='Parameters is the list of parameters that is applied to resolved Kafka trigger object.', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { kafka+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='Parameters is the list of parameters that is applied to resolved Kafka trigger object.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { kafka+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPartition':: d.fn(help='Partition to write data to.', args=[d.arg(name='partition', type=d.T.integer)]),
    withPartition(partition): { kafka+: { partition: partition } },
    '#withPartitioningKey':: d.fn(help='The partitioning key for the messages put on the Kafka topic.\nDefaults to broker url.\n+optional.', args=[d.arg(name='partitioningKey', type=d.T.string)]),
    withPartitioningKey(partitioningKey): { kafka+: { partitioningKey: partitioningKey } },
    '#withPayload':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { kafka+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { kafka+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
    '#withRequiredAcks':: d.fn(help='RequiredAcks used in producer to tell the broker how many replica acknowledgements\nDefaults to 1 (Only wait for the leader to ack).\n+optional.', args=[d.arg(name='requiredAcks', type=d.T.integer)]),
    withRequiredAcks(requiredAcks): { kafka+: { requiredAcks: requiredAcks } },
    '#withTopic':: d.fn(help='', args=[d.arg(name='topic', type=d.T.string)]),
    withTopic(topic): { kafka+: { topic: topic } },
    '#withUrl':: d.fn(help='URL of the Kafka broker, multiple URLs separated by comma.', args=[d.arg(name='url', type=d.T.string)]),
    withUrl(url): { kafka+: { url: url } },
    '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
    withVersion(version): { kafka+: { version: version } },
  },
  '#log':: d.obj(help=''),
  log: {
    '#withIntervalSeconds':: d.fn(help='', args=[d.arg(name='intervalSeconds', type=d.T.string)]),
    withIntervalSeconds(intervalSeconds): { log+: { intervalSeconds: intervalSeconds } },
  },
  '#nats':: d.obj(help='NATSTrigger refers to the specification of the NATS trigger.'),
  nats: {
    '#tls':: d.obj(help='TLSConfig refers to TLS configuration for a client.'),
    tls: {
      '#caCertSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      caCertSecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { nats+: { tls+: { caCertSecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { nats+: { tls+: { caCertSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { nats+: { tls+: { caCertSecret+: { optional: optional } } } },
      },
      '#clientCertSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      clientCertSecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { nats+: { tls+: { clientCertSecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { nats+: { tls+: { clientCertSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { nats+: { tls+: { clientCertSecret+: { optional: optional } } } },
      },
      '#clientKeySecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      clientKeySecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { nats+: { tls+: { clientKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { nats+: { tls+: { clientKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { nats+: { tls+: { clientKeySecret+: { optional: optional } } } },
      },
      '#withCaCertPath':: d.fn(help='', args=[d.arg(name='caCertPath', type=d.T.string)]),
      withCaCertPath(caCertPath): { nats+: { tls+: { caCertPath: caCertPath } } },
      '#withClientCertPath':: d.fn(help='', args=[d.arg(name='clientCertPath', type=d.T.string)]),
      withClientCertPath(clientCertPath): { nats+: { tls+: { clientCertPath: clientCertPath } } },
      '#withClientKeyPath':: d.fn(help='', args=[d.arg(name='clientKeyPath', type=d.T.string)]),
      withClientKeyPath(clientKeyPath): { nats+: { tls+: { clientKeyPath: clientKeyPath } } },
    },
    '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { nats+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { nats+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPayload':: d.fn(help='', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { nats+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { nats+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
    '#withSubject':: d.fn(help='Name of the subject to put message on.', args=[d.arg(name='subject', type=d.T.string)]),
    withSubject(subject): { nats+: { subject: subject } },
    '#withUrl':: d.fn(help='URL of the NATS cluster.', args=[d.arg(name='url', type=d.T.string)]),
    withUrl(url): { nats+: { url: url } },
  },
  '#openWhisk':: d.obj(help='OpenWhiskTrigger refers to the specification of the OpenWhisk trigger.'),
  openWhisk: {
    '#authToken':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    authToken: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { openWhisk+: { authToken+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { openWhisk+: { authToken+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { openWhisk+: { authToken+: { optional: optional } } },
    },
    '#withActionName':: d.fn(help='Name of the action/function.', args=[d.arg(name='actionName', type=d.T.string)]),
    withActionName(actionName): { openWhisk+: { actionName: actionName } },
    '#withHost':: d.fn(help='Host URL of the OpenWhisk.', args=[d.arg(name='host', type=d.T.string)]),
    withHost(host): { openWhisk+: { host: host } },
    '#withNamespace':: d.fn(help='Namespace for the action.\nDefaults to "_".\n+optional.', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { openWhisk+: { namespace: namespace } },
    '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { openWhisk+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { openWhisk+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withPayload':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.', args=[d.arg(name='payload', type=d.T.array)]),
    withPayload(payload): { openWhisk+: { payload: if std.isArray(v=payload) then payload else [payload] } },
    '#withPayloadMixin':: d.fn(help='Payload is the list of key-value extracted from an event payload to construct the request payload.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
    withPayloadMixin(payload): { openWhisk+: { payload+: if std.isArray(v=payload) then payload else [payload] } },
    '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
    withVersion(version): { openWhisk+: { version: version } },
  },
  '#slack':: d.obj(help='SlackTrigger refers to the specification of the slack notification trigger.'),
  slack: {
    '#slackToken':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
    slackToken: {
      '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { slack+: { slackToken+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { slack+: { slackToken+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { slack+: { slackToken+: { optional: optional } } },
    },
    '#withChannel':: d.fn(help='', args=[d.arg(name='channel', type=d.T.string)]),
    withChannel(channel): { slack+: { channel: channel } },
    '#withMessage':: d.fn(help='', args=[d.arg(name='message', type=d.T.string)]),
    withMessage(message): { slack+: { message: message } },
    '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { slack+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { slack+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
  },
  '#switch':: d.obj(help=''),
  switch: {
    '#withAll':: d.fn(help='', args=[d.arg(name='all', type=d.T.array)]),
    withAll(all): { switch+: { all: if std.isArray(v=all) then all else [all] } },
    '#withAllMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='all', type=d.T.array)]),
    withAllMixin(all): { switch+: { all+: if std.isArray(v=all) then all else [all] } },
    '#withAny':: d.fn(help='', args=[d.arg(name='any', type=d.T.array)]),
    withAny(any): { switch+: { any: if std.isArray(v=any) then any else [any] } },
    '#withAnyMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='any', type=d.T.array)]),
    withAnyMixin(any): { switch+: { any+: if std.isArray(v=any) then any else [any] } },
  },
  '#withConditions':: d.fn(help='', args=[d.arg(name='conditions', type=d.T.string)]),
  withConditions(conditions): { conditions: conditions },
  '#withName':: d.fn(help='Name is a unique name of the action to take.', args=[d.arg(name='name', type=d.T.string)]),
  withName(name): { name: name },
  '#mixin': 'ignore',
  mixin: self,
}

{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='eventContext', url='', help=''),
  '#withDatacontenttype':: d.fn(help='DataContentType - A MIME (RFC2046) string describing the media type of `data`.', args=[d.arg(name='datacontenttype', type=d.T.string)]),
  withDatacontenttype(datacontenttype): { datacontenttype: datacontenttype },
  '#withId':: d.fn(help='ID of the event; must be non-empty and unique within the scope of the producer.', args=[d.arg(name='id', type=d.T.string)]),
  withId(id): { id: id },
  '#withSource':: d.fn(help='Source - A URI describing the event producer.', args=[d.arg(name='source', type=d.T.string)]),
  withSource(source): { source: source },
  '#withSpecversion':: d.fn(help='SpecVersion - The version of the CloudEvents specification used by the io.argoproj.workflow.v1alpha1.', args=[d.arg(name='specversion', type=d.T.string)]),
  withSpecversion(specversion): { specversion: specversion },
  '#withSubject':: d.fn(help='', args=[d.arg(name='subject', type=d.T.string)]),
  withSubject(subject): { subject: subject },
  '#withTime':: d.fn(help='Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.', args=[d.arg(name='time', type=d.T.string)]),
  withTime(time): { time: time },
  '#withType':: d.fn(help='Type - The type of the occurrence which has happened.', args=[d.arg(name='type', type=d.T.string)]),
  withType(type): { type: type },
  '#mixin': 'ignore',
  mixin: self,
}

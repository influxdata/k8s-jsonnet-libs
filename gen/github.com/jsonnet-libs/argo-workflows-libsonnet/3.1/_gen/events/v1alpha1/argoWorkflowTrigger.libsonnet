{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='argoWorkflowTrigger', url='', help=''),
  '#groupVersionResource':: d.obj(help='+protobuf.options.(gogoproto.goproto_stringer)=false'),
  groupVersionResource: {
    '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
    withGroup(group): { groupVersionResource+: { group: group } },
    '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
    withResource(resource): { groupVersionResource+: { resource: resource } },
    '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
    withVersion(version): { groupVersionResource+: { version: version } },
  },
  '#source':: d.obj(help=''),
  source: {
    '#configmap':: d.obj(help='Selects a key from a ConfigMap.'),
    configmap: {
      '#withKey':: d.fn(help='The key to select.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { source+: { configmap+: { key: key } } },
      '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { source+: { configmap+: { name: name } } },
      '#withOptional':: d.fn(help='Specify whether the ConfigMap or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { source+: { configmap+: { optional: optional } } },
    },
    '#file':: d.obj(help=''),
    file: {
      '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
      withPath(path): { source+: { file+: { path: path } } },
    },
    '#git':: d.obj(help=''),
    git: {
      '#creds':: d.obj(help=''),
      creds: {
        '#password':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        password: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { source+: { git+: { creds+: { password+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { source+: { git+: { creds+: { password+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { source+: { git+: { creds+: { password+: { optional: optional } } } } },
        },
        '#username':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
        username: {
          '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { source+: { git+: { creds+: { username+: { key: key } } } } },
          '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { source+: { git+: { creds+: { username+: { name: name } } } } },
          '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { source+: { git+: { creds+: { username+: { optional: optional } } } } },
        },
      },
      '#remote':: d.obj(help=''),
      remote: {
        '#withName':: d.fn(help='Name of the remote to fetch from.', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { source+: { git+: { remote+: { name: name } } } },
        '#withUrls':: d.fn(help='URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.', args=[d.arg(name='urls', type=d.T.array)]),
        withUrls(urls): { source+: { git+: { remote+: { urls: if std.isArray(v=urls) then urls else [urls] } } } },
        '#withUrlsMixin':: d.fn(help='URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='urls', type=d.T.array)]),
        withUrlsMixin(urls): { source+: { git+: { remote+: { urls+: if std.isArray(v=urls) then urls else [urls] } } } },
      },
      '#sshKeySecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      sshKeySecret: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { source+: { git+: { sshKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { source+: { git+: { sshKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { source+: { git+: { sshKeySecret+: { optional: optional } } } },
      },
      '#withBranch':: d.fn(help='', args=[d.arg(name='branch', type=d.T.string)]),
      withBranch(branch): { source+: { git+: { branch: branch } } },
      '#withCloneDirectory':: d.fn(help="Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.\nHence we don't use any specific git provider client.", args=[d.arg(name='cloneDirectory', type=d.T.string)]),
      withCloneDirectory(cloneDirectory): { source+: { git+: { cloneDirectory: cloneDirectory } } },
      '#withFilePath':: d.fn(help='', args=[d.arg(name='filePath', type=d.T.string)]),
      withFilePath(filePath): { source+: { git+: { filePath: filePath } } },
      '#withRef':: d.fn(help='', args=[d.arg(name='ref', type=d.T.string)]),
      withRef(ref): { source+: { git+: { ref: ref } } },
      '#withSshKeyPath':: d.fn(help='', args=[d.arg(name='sshKeyPath', type=d.T.string)]),
      withSshKeyPath(sshKeyPath): { source+: { git+: { sshKeyPath: sshKeyPath } } },
      '#withTag':: d.fn(help='', args=[d.arg(name='tag', type=d.T.string)]),
      withTag(tag): { source+: { git+: { tag: tag } } },
      '#withUrl':: d.fn(help='', args=[d.arg(name='url', type=d.T.string)]),
      withUrl(url): { source+: { git+: { url: url } } },
    },
    '#resource':: d.obj(help='Resource represent arbitrary structured data.'),
    resource: {
      '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
      withValue(value): { source+: { resource+: { value: value } } },
    },
    '#s3':: d.obj(help=''),
    s3: {
      '#accessKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      accessKey: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { source+: { s3+: { accessKey+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { source+: { s3+: { accessKey+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { source+: { s3+: { accessKey+: { optional: optional } } } },
      },
      '#bucket':: d.obj(help=''),
      bucket: {
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { source+: { s3+: { bucket+: { key: key } } } },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { source+: { s3+: { bucket+: { name: name } } } },
      },
      '#filter':: d.obj(help=''),
      filter: {
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { source+: { s3+: { filter+: { prefix: prefix } } } },
        '#withSuffix':: d.fn(help='', args=[d.arg(name='suffix', type=d.T.string)]),
        withSuffix(suffix): { source+: { s3+: { filter+: { suffix: suffix } } } },
      },
      '#secretKey':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
      secretKey: {
        '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { source+: { s3+: { secretKey+: { key: key } } } },
        '#withName':: d.fn(help='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { source+: { s3+: { secretKey+: { name: name } } } },
        '#withOptional':: d.fn(help='Specify whether the Secret or its key must be defined', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { source+: { s3+: { secretKey+: { optional: optional } } } },
      },
      '#withEndpoint':: d.fn(help='', args=[d.arg(name='endpoint', type=d.T.string)]),
      withEndpoint(endpoint): { source+: { s3+: { endpoint: endpoint } } },
      '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
      withEvents(events): { source+: { s3+: { events: if std.isArray(v=events) then events else [events] } } },
      '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
      withEventsMixin(events): { source+: { s3+: { events+: if std.isArray(v=events) then events else [events] } } },
      '#withInsecure':: d.fn(help='', args=[d.arg(name='insecure', type=d.T.boolean)]),
      withInsecure(insecure): { source+: { s3+: { insecure: insecure } } },
      '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
      withMetadata(metadata): { source+: { s3+: { metadata: metadata } } },
      '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
      withMetadataMixin(metadata): { source+: { s3+: { metadata+: metadata } } },
      '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { source+: { s3+: { region: region } } },
    },
    '#url':: d.obj(help='URLArtifact contains information about an artifact at an http endpoint.'),
    url: {
      '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
      withPath(path): { source+: { url+: { path: path } } },
      '#withVerifyCert':: d.fn(help='', args=[d.arg(name='verifyCert', type=d.T.boolean)]),
      withVerifyCert(verifyCert): { source+: { url+: { verifyCert: verifyCert } } },
    },
    '#withInline':: d.fn(help='', args=[d.arg(name='inline', type=d.T.string)]),
    withInline(inline): { source+: { inline: inline } },
  },
  '#withOperation':: d.fn(help='', args=[d.arg(name='operation', type=d.T.string)]),
  withOperation(operation): { operation: operation },
  '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
  withParameters(parameters): { parameters: if std.isArray(v=parameters) then parameters else [parameters] },
  '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
  withParametersMixin(parameters): { parameters+: if std.isArray(v=parameters) then parameters else [parameters] },
  '#mixin': 'ignore',
  mixin: self,
}

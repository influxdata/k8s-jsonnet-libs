{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='trigger', url='', help=''),
  '#policy':: d.obj(help=''),
  policy: {
    '#k8s':: d.obj(help=''),
    k8s: {
      '#backoff':: d.obj(help=''),
      backoff: {
        '#duration':: d.obj(help=''),
        duration: {
          '#withInt64Val':: d.fn(help='', args=[d.arg(name='int64Val', type=d.T.string)]),
          withInt64Val(int64Val): { policy+: { k8s+: { backoff+: { duration+: { int64Val: int64Val } } } } },
          '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
          withStrVal(strVal): { policy+: { k8s+: { backoff+: { duration+: { strVal: strVal } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { policy+: { k8s+: { backoff+: { duration+: { type: type } } } } },
        },
        '#factor':: d.obj(help='"Amount represent a numeric amount."'),
        factor: {
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { policy+: { k8s+: { backoff+: { factor+: { value: value } } } } },
        },
        '#jitter':: d.obj(help='"Amount represent a numeric amount."'),
        jitter: {
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { policy+: { k8s+: { backoff+: { jitter+: { value: value } } } } },
        },
        '#withSteps':: d.fn(help='', args=[d.arg(name='steps', type=d.T.integer)]),
        withSteps(steps): { policy+: { k8s+: { backoff+: { steps: steps } } } },
      },
      '#withErrorOnBackoffTimeout':: d.fn(help='', args=[d.arg(name='errorOnBackoffTimeout', type=d.T.boolean)]),
      withErrorOnBackoffTimeout(errorOnBackoffTimeout): { policy+: { k8s+: { errorOnBackoffTimeout: errorOnBackoffTimeout } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { policy+: { k8s+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { policy+: { k8s+: { labels+: labels } } },
    },
  },
  '#retryStrategy':: d.obj(help=''),
  retryStrategy: {
    '#duration':: d.obj(help=''),
    duration: {
      '#withInt64Val':: d.fn(help='', args=[d.arg(name='int64Val', type=d.T.string)]),
      withInt64Val(int64Val): { retryStrategy+: { duration+: { int64Val: int64Val } } },
      '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
      withStrVal(strVal): { retryStrategy+: { duration+: { strVal: strVal } } },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { retryStrategy+: { duration+: { type: type } } },
    },
    '#factor':: d.obj(help='"Amount represent a numeric amount."'),
    factor: {
      '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
      withValue(value): { retryStrategy+: { factor+: { value: value } } },
    },
    '#jitter':: d.obj(help='"Amount represent a numeric amount."'),
    jitter: {
      '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
      withValue(value): { retryStrategy+: { jitter+: { value: value } } },
    },
    '#withSteps':: d.fn(help='', args=[d.arg(name='steps', type=d.T.integer)]),
    withSteps(steps): { retryStrategy+: { steps: steps } },
  },
  '#template':: d.obj(help='"TriggerTemplate is the template that describes trigger specification."'),
  template: {
    '#argoWorkflow':: d.obj(help=''),
    argoWorkflow: {
      '#groupVersionResource':: d.obj(help='"+protobuf.options.(gogoproto.goproto_stringer)=false"'),
      groupVersionResource: {
        '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
        withGroup(group): { template+: { argoWorkflow+: { groupVersionResource+: { group: group } } } },
        '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
        withResource(resource): { template+: { argoWorkflow+: { groupVersionResource+: { resource: resource } } } },
        '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
        withVersion(version): { template+: { argoWorkflow+: { groupVersionResource+: { version: version } } } },
      },
      '#source':: d.obj(help=''),
      source: {
        '#configmap':: d.obj(help='"Selects a key from a ConfigMap."'),
        configmap: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { argoWorkflow+: { source+: { configmap+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { argoWorkflow+: { source+: { configmap+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { argoWorkflow+: { source+: { configmap+: { optional: optional } } } } },
        },
        '#file':: d.obj(help=''),
        file: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { template+: { argoWorkflow+: { source+: { file+: { path: path } } } } },
        },
        '#git':: d.obj(help=''),
        git: {
          '#creds':: d.obj(help=''),
          creds: {
            '#password':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { template+: { argoWorkflow+: { source+: { git+: { creds+: { password+: { key: key } } } } } } },
              '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { template+: { argoWorkflow+: { source+: { git+: { creds+: { password+: { name: name } } } } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { template+: { argoWorkflow+: { source+: { git+: { creds+: { password+: { optional: optional } } } } } } },
            },
            '#username':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { template+: { argoWorkflow+: { source+: { git+: { creds+: { username+: { key: key } } } } } } },
              '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { template+: { argoWorkflow+: { source+: { git+: { creds+: { username+: { name: name } } } } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { template+: { argoWorkflow+: { source+: { git+: { creds+: { username+: { optional: optional } } } } } } },
            },
          },
          '#remote':: d.obj(help=''),
          remote: {
            '#withName':: d.fn(help='"Name of the remote to fetch from."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { argoWorkflow+: { source+: { git+: { remote+: { name: name } } } } } },
            '#withUrls':: d.fn(help='"URLs the URLs of a remote repository. It must be non-empty. Fetch will\\nalways use the first URL, while push will use all of them."', args=[d.arg(name='urls', type=d.T.array)]),
            withUrls(urls): { template+: { argoWorkflow+: { source+: { git+: { remote+: { urls: if std.isArray(v=urls) then urls else [urls] } } } } } },
            '#withUrlsMixin':: d.fn(help='"URLs the URLs of a remote repository. It must be non-empty. Fetch will\\nalways use the first URL, while push will use all of them."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='urls', type=d.T.array)]),
            withUrlsMixin(urls): { template+: { argoWorkflow+: { source+: { git+: { remote+: { urls+: if std.isArray(v=urls) then urls else [urls] } } } } } },
          },
          '#sshKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          sshKeySecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { argoWorkflow+: { source+: { git+: { sshKeySecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { argoWorkflow+: { source+: { git+: { sshKeySecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { template+: { argoWorkflow+: { source+: { git+: { sshKeySecret+: { optional: optional } } } } } },
          },
          '#withBranch':: d.fn(help='', args=[d.arg(name='branch', type=d.T.string)]),
          withBranch(branch): { template+: { argoWorkflow+: { source+: { git+: { branch: branch } } } } },
          '#withCloneDirectory':: d.fn(help="\"Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.\\nHence we don't use any specific git provider client.\"", args=[d.arg(name='cloneDirectory', type=d.T.string)]),
          withCloneDirectory(cloneDirectory): { template+: { argoWorkflow+: { source+: { git+: { cloneDirectory: cloneDirectory } } } } },
          '#withFilePath':: d.fn(help='', args=[d.arg(name='filePath', type=d.T.string)]),
          withFilePath(filePath): { template+: { argoWorkflow+: { source+: { git+: { filePath: filePath } } } } },
          '#withRef':: d.fn(help='', args=[d.arg(name='ref', type=d.T.string)]),
          withRef(ref): { template+: { argoWorkflow+: { source+: { git+: { ref: ref } } } } },
          '#withSshKeyPath':: d.fn(help='', args=[d.arg(name='sshKeyPath', type=d.T.string)]),
          withSshKeyPath(sshKeyPath): { template+: { argoWorkflow+: { source+: { git+: { sshKeyPath: sshKeyPath } } } } },
          '#withTag':: d.fn(help='', args=[d.arg(name='tag', type=d.T.string)]),
          withTag(tag): { template+: { argoWorkflow+: { source+: { git+: { tag: tag } } } } },
          '#withUrl':: d.fn(help='', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { template+: { argoWorkflow+: { source+: { git+: { url: url } } } } },
        },
        '#resource':: d.obj(help='"Resource represent arbitrary structured data."'),
        resource: {
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { template+: { argoWorkflow+: { source+: { resource+: { value: value } } } } },
        },
        '#s3':: d.obj(help=''),
        s3: {
          '#accessKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          accessKey: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { argoWorkflow+: { source+: { s3+: { accessKey+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { argoWorkflow+: { source+: { s3+: { accessKey+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { template+: { argoWorkflow+: { source+: { s3+: { accessKey+: { optional: optional } } } } } },
          },
          '#bucket':: d.obj(help=''),
          bucket: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { argoWorkflow+: { source+: { s3+: { bucket+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { argoWorkflow+: { source+: { s3+: { bucket+: { name: name } } } } } },
          },
          '#filter':: d.obj(help=''),
          filter: {
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { template+: { argoWorkflow+: { source+: { s3+: { filter+: { prefix: prefix } } } } } },
            '#withSuffix':: d.fn(help='', args=[d.arg(name='suffix', type=d.T.string)]),
            withSuffix(suffix): { template+: { argoWorkflow+: { source+: { s3+: { filter+: { suffix: suffix } } } } } },
          },
          '#secretKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          secretKey: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { argoWorkflow+: { source+: { s3+: { secretKey+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { argoWorkflow+: { source+: { s3+: { secretKey+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { template+: { argoWorkflow+: { source+: { s3+: { secretKey+: { optional: optional } } } } } },
          },
          '#withEndpoint':: d.fn(help='', args=[d.arg(name='endpoint', type=d.T.string)]),
          withEndpoint(endpoint): { template+: { argoWorkflow+: { source+: { s3+: { endpoint: endpoint } } } } },
          '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
          withEvents(events): { template+: { argoWorkflow+: { source+: { s3+: { events: if std.isArray(v=events) then events else [events] } } } } },
          '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
          withEventsMixin(events): { template+: { argoWorkflow+: { source+: { s3+: { events+: if std.isArray(v=events) then events else [events] } } } } },
          '#withInsecure':: d.fn(help='', args=[d.arg(name='insecure', type=d.T.boolean)]),
          withInsecure(insecure): { template+: { argoWorkflow+: { source+: { s3+: { insecure: insecure } } } } },
          '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
          withMetadata(metadata): { template+: { argoWorkflow+: { source+: { s3+: { metadata: metadata } } } } },
          '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
          withMetadataMixin(metadata): { template+: { argoWorkflow+: { source+: { s3+: { metadata+: metadata } } } } },
          '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
          withRegion(region): { template+: { argoWorkflow+: { source+: { s3+: { region: region } } } } },
        },
        '#url':: d.obj(help='"URLArtifact contains information about an artifact at an http endpoint."'),
        url: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { template+: { argoWorkflow+: { source+: { url+: { path: path } } } } },
          '#withVerifyCert':: d.fn(help='', args=[d.arg(name='verifyCert', type=d.T.boolean)]),
          withVerifyCert(verifyCert): { template+: { argoWorkflow+: { source+: { url+: { verifyCert: verifyCert } } } } },
        },
        '#withInline':: d.fn(help='', args=[d.arg(name='inline', type=d.T.string)]),
        withInline(inline): { template+: { argoWorkflow+: { source+: { inline: inline } } } },
      },
      '#withOperation':: d.fn(help='', args=[d.arg(name='operation', type=d.T.string)]),
      withOperation(operation): { template+: { argoWorkflow+: { operation: operation } } },
      '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { argoWorkflow+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { argoWorkflow+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
    },
    '#awsLambda':: d.obj(help=''),
    awsLambda: {
      '#accessKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      accessKey: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { awsLambda+: { accessKey+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { awsLambda+: { accessKey+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { awsLambda+: { accessKey+: { optional: optional } } } },
      },
      '#secretKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      secretKey: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { awsLambda+: { secretKey+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { awsLambda+: { secretKey+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { awsLambda+: { secretKey+: { optional: optional } } } },
      },
      '#withFunctionName':: d.fn(help='"FunctionName refers to the name of the function to invoke."', args=[d.arg(name='functionName', type=d.T.string)]),
      withFunctionName(functionName): { template+: { awsLambda+: { functionName: functionName } } },
      '#withInvocationType':: d.fn(help="\"Choose from the following options.\\n\\n   * RequestResponse (default) - Invoke the function synchronously. Keep\\n   the connection open until the function returns a response or times out.\\n   The API response includes the function response and additional data.\\n\\n   * Event - Invoke the function asynchronously. Send events that fail multiple\\n   times to the function's dead-letter queue (if it's configured). The API\\n   response only includes a status code.\\n\\n   * DryRun - Validate parameter values and verify that the user or role\\n   has permission to invoke the function.\\n+optional\"", args=[d.arg(name='invocationType', type=d.T.string)]),
      withInvocationType(invocationType): { template+: { awsLambda+: { invocationType: invocationType } } },
      '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { awsLambda+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { awsLambda+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPayload':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { awsLambda+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { awsLambda+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
      '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { template+: { awsLambda+: { region: region } } },
    },
    '#azureEventHubs':: d.obj(help=''),
    azureEventHubs: {
      '#sharedAccessKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      sharedAccessKey: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { azureEventHubs+: { sharedAccessKey+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { azureEventHubs+: { sharedAccessKey+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { azureEventHubs+: { sharedAccessKey+: { optional: optional } } } },
      },
      '#sharedAccessKeyName':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      sharedAccessKeyName: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { azureEventHubs+: { sharedAccessKeyName+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { azureEventHubs+: { sharedAccessKeyName+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { azureEventHubs+: { sharedAccessKeyName+: { optional: optional } } } },
      },
      '#withFqdn':: d.fn(help='', args=[d.arg(name='fqdn', type=d.T.string)]),
      withFqdn(fqdn): { template+: { azureEventHubs+: { fqdn: fqdn } } },
      '#withHubName':: d.fn(help='', args=[d.arg(name='hubName', type=d.T.string)]),
      withHubName(hubName): { template+: { azureEventHubs+: { hubName: hubName } } },
      '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { azureEventHubs+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { azureEventHubs+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPayload':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { azureEventHubs+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { azureEventHubs+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
    },
    '#custom':: d.obj(help='"CustomTrigger refers to the specification of the custom trigger."'),
    custom: {
      '#certSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      certSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { custom+: { certSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { custom+: { certSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { custom+: { certSecret+: { optional: optional } } } },
      },
      '#withCertFilePath':: d.fn(help='', args=[d.arg(name='certFilePath', type=d.T.string)]),
      withCertFilePath(certFilePath): { template+: { custom+: { certFilePath: certFilePath } } },
      '#withParameters':: d.fn(help='"Parameters is the list of parameters that is applied to resolved custom trigger trigger object."', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { custom+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='"Parameters is the list of parameters that is applied to resolved custom trigger trigger object."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { custom+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPayload':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { custom+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { custom+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
      '#withSecure':: d.fn(help='', args=[d.arg(name='secure', type=d.T.boolean)]),
      withSecure(secure): { template+: { custom+: { secure: secure } } },
      '#withServerNameOverride':: d.fn(help='"ServerNameOverride for the secure connection between sensor and custom trigger gRPC server."', args=[d.arg(name='serverNameOverride', type=d.T.string)]),
      withServerNameOverride(serverNameOverride): { template+: { custom+: { serverNameOverride: serverNameOverride } } },
      '#withServerURL':: d.fn(help='', args=[d.arg(name='serverURL', type=d.T.string)]),
      withServerURL(serverURL): { template+: { custom+: { serverURL: serverURL } } },
      '#withSpec':: d.fn(help='"Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret."', args=[d.arg(name='spec', type=d.T.object)]),
      withSpec(spec): { template+: { custom+: { spec: spec } } },
      '#withSpecMixin':: d.fn(help='"Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='spec', type=d.T.object)]),
      withSpecMixin(spec): { template+: { custom+: { spec+: spec } } },
    },
    '#http':: d.obj(help=''),
    http: {
      '#basicAuth':: d.obj(help=''),
      basicAuth: {
        '#password':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        password: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { http+: { basicAuth+: { password+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { http+: { basicAuth+: { password+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { http+: { basicAuth+: { password+: { optional: optional } } } } },
        },
        '#username':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        username: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { http+: { basicAuth+: { username+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { http+: { basicAuth+: { username+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { http+: { basicAuth+: { username+: { optional: optional } } } } },
        },
      },
      '#tls':: d.obj(help='"TLSConfig refers to TLS configuration for a client."'),
      tls: {
        '#caCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        caCertSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { http+: { tls+: { caCertSecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { http+: { tls+: { caCertSecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { http+: { tls+: { caCertSecret+: { optional: optional } } } } },
        },
        '#clientCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        clientCertSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { http+: { tls+: { clientCertSecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { http+: { tls+: { clientCertSecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { http+: { tls+: { clientCertSecret+: { optional: optional } } } } },
        },
        '#clientKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        clientKeySecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { http+: { tls+: { clientKeySecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { http+: { tls+: { clientKeySecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { http+: { tls+: { clientKeySecret+: { optional: optional } } } } },
        },
        '#withCaCertPath':: d.fn(help='', args=[d.arg(name='caCertPath', type=d.T.string)]),
        withCaCertPath(caCertPath): { template+: { http+: { tls+: { caCertPath: caCertPath } } } },
        '#withClientCertPath':: d.fn(help='', args=[d.arg(name='clientCertPath', type=d.T.string)]),
        withClientCertPath(clientCertPath): { template+: { http+: { tls+: { clientCertPath: clientCertPath } } } },
        '#withClientKeyPath':: d.fn(help='', args=[d.arg(name='clientKeyPath', type=d.T.string)]),
        withClientKeyPath(clientKeyPath): { template+: { http+: { tls+: { clientKeyPath: clientKeyPath } } } },
      },
      '#withHeaders':: d.fn(help='', args=[d.arg(name='headers', type=d.T.object)]),
      withHeaders(headers): { template+: { http+: { headers: headers } } },
      '#withHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.object)]),
      withHeadersMixin(headers): { template+: { http+: { headers+: headers } } },
      '#withMethod':: d.fn(help='', args=[d.arg(name='method', type=d.T.string)]),
      withMethod(method): { template+: { http+: { method: method } } },
      '#withParameters':: d.fn(help="\"Parameters is the list of key-value extracted from event's payload that are applied to\\nthe HTTP trigger resource.\"", args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { http+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help="\"Parameters is the list of key-value extracted from event's payload that are applied to\\nthe HTTP trigger resource.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { http+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPayload':: d.fn(help='', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { http+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { http+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
      '#withSecureHeaders':: d.fn(help='', args=[d.arg(name='secureHeaders', type=d.T.array)]),
      withSecureHeaders(secureHeaders): { template+: { http+: { secureHeaders: if std.isArray(v=secureHeaders) then secureHeaders else [secureHeaders] } } },
      '#withSecureHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='secureHeaders', type=d.T.array)]),
      withSecureHeadersMixin(secureHeaders): { template+: { http+: { secureHeaders+: if std.isArray(v=secureHeaders) then secureHeaders else [secureHeaders] } } },
      '#withTimeout':: d.fn(help='', args=[d.arg(name='timeout', type=d.T.string)]),
      withTimeout(timeout): { template+: { http+: { timeout: timeout } } },
      '#withUrl':: d.fn(help='"URL refers to the URL to send HTTP request to."', args=[d.arg(name='url', type=d.T.string)]),
      withUrl(url): { template+: { http+: { url: url } } },
    },
    '#k8s':: d.obj(help=''),
    k8s: {
      '#groupVersionResource':: d.obj(help='"+protobuf.options.(gogoproto.goproto_stringer)=false"'),
      groupVersionResource: {
        '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
        withGroup(group): { template+: { k8s+: { groupVersionResource+: { group: group } } } },
        '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
        withResource(resource): { template+: { k8s+: { groupVersionResource+: { resource: resource } } } },
        '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
        withVersion(version): { template+: { k8s+: { groupVersionResource+: { version: version } } } },
      },
      '#source':: d.obj(help=''),
      source: {
        '#configmap':: d.obj(help='"Selects a key from a ConfigMap."'),
        configmap: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { k8s+: { source+: { configmap+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { k8s+: { source+: { configmap+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { k8s+: { source+: { configmap+: { optional: optional } } } } },
        },
        '#file':: d.obj(help=''),
        file: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { template+: { k8s+: { source+: { file+: { path: path } } } } },
        },
        '#git':: d.obj(help=''),
        git: {
          '#creds':: d.obj(help=''),
          creds: {
            '#password':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { template+: { k8s+: { source+: { git+: { creds+: { password+: { key: key } } } } } } },
              '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { template+: { k8s+: { source+: { git+: { creds+: { password+: { name: name } } } } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { template+: { k8s+: { source+: { git+: { creds+: { password+: { optional: optional } } } } } } },
            },
            '#username':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { template+: { k8s+: { source+: { git+: { creds+: { username+: { key: key } } } } } } },
              '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { template+: { k8s+: { source+: { git+: { creds+: { username+: { name: name } } } } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { template+: { k8s+: { source+: { git+: { creds+: { username+: { optional: optional } } } } } } },
            },
          },
          '#remote':: d.obj(help=''),
          remote: {
            '#withName':: d.fn(help='"Name of the remote to fetch from."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { k8s+: { source+: { git+: { remote+: { name: name } } } } } },
            '#withUrls':: d.fn(help='"URLs the URLs of a remote repository. It must be non-empty. Fetch will\\nalways use the first URL, while push will use all of them."', args=[d.arg(name='urls', type=d.T.array)]),
            withUrls(urls): { template+: { k8s+: { source+: { git+: { remote+: { urls: if std.isArray(v=urls) then urls else [urls] } } } } } },
            '#withUrlsMixin':: d.fn(help='"URLs the URLs of a remote repository. It must be non-empty. Fetch will\\nalways use the first URL, while push will use all of them."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='urls', type=d.T.array)]),
            withUrlsMixin(urls): { template+: { k8s+: { source+: { git+: { remote+: { urls+: if std.isArray(v=urls) then urls else [urls] } } } } } },
          },
          '#sshKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          sshKeySecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { k8s+: { source+: { git+: { sshKeySecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { k8s+: { source+: { git+: { sshKeySecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { template+: { k8s+: { source+: { git+: { sshKeySecret+: { optional: optional } } } } } },
          },
          '#withBranch':: d.fn(help='', args=[d.arg(name='branch', type=d.T.string)]),
          withBranch(branch): { template+: { k8s+: { source+: { git+: { branch: branch } } } } },
          '#withCloneDirectory':: d.fn(help="\"Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.\\nHence we don't use any specific git provider client.\"", args=[d.arg(name='cloneDirectory', type=d.T.string)]),
          withCloneDirectory(cloneDirectory): { template+: { k8s+: { source+: { git+: { cloneDirectory: cloneDirectory } } } } },
          '#withFilePath':: d.fn(help='', args=[d.arg(name='filePath', type=d.T.string)]),
          withFilePath(filePath): { template+: { k8s+: { source+: { git+: { filePath: filePath } } } } },
          '#withRef':: d.fn(help='', args=[d.arg(name='ref', type=d.T.string)]),
          withRef(ref): { template+: { k8s+: { source+: { git+: { ref: ref } } } } },
          '#withSshKeyPath':: d.fn(help='', args=[d.arg(name='sshKeyPath', type=d.T.string)]),
          withSshKeyPath(sshKeyPath): { template+: { k8s+: { source+: { git+: { sshKeyPath: sshKeyPath } } } } },
          '#withTag':: d.fn(help='', args=[d.arg(name='tag', type=d.T.string)]),
          withTag(tag): { template+: { k8s+: { source+: { git+: { tag: tag } } } } },
          '#withUrl':: d.fn(help='', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { template+: { k8s+: { source+: { git+: { url: url } } } } },
        },
        '#resource':: d.obj(help='"Resource represent arbitrary structured data."'),
        resource: {
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { template+: { k8s+: { source+: { resource+: { value: value } } } } },
        },
        '#s3':: d.obj(help=''),
        s3: {
          '#accessKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          accessKey: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { k8s+: { source+: { s3+: { accessKey+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { k8s+: { source+: { s3+: { accessKey+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { template+: { k8s+: { source+: { s3+: { accessKey+: { optional: optional } } } } } },
          },
          '#bucket':: d.obj(help=''),
          bucket: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { k8s+: { source+: { s3+: { bucket+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { k8s+: { source+: { s3+: { bucket+: { name: name } } } } } },
          },
          '#filter':: d.obj(help=''),
          filter: {
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { template+: { k8s+: { source+: { s3+: { filter+: { prefix: prefix } } } } } },
            '#withSuffix':: d.fn(help='', args=[d.arg(name='suffix', type=d.T.string)]),
            withSuffix(suffix): { template+: { k8s+: { source+: { s3+: { filter+: { suffix: suffix } } } } } },
          },
          '#secretKey':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          secretKey: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { template+: { k8s+: { source+: { s3+: { secretKey+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { template+: { k8s+: { source+: { s3+: { secretKey+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { template+: { k8s+: { source+: { s3+: { secretKey+: { optional: optional } } } } } },
          },
          '#withEndpoint':: d.fn(help='', args=[d.arg(name='endpoint', type=d.T.string)]),
          withEndpoint(endpoint): { template+: { k8s+: { source+: { s3+: { endpoint: endpoint } } } } },
          '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
          withEvents(events): { template+: { k8s+: { source+: { s3+: { events: if std.isArray(v=events) then events else [events] } } } } },
          '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
          withEventsMixin(events): { template+: { k8s+: { source+: { s3+: { events+: if std.isArray(v=events) then events else [events] } } } } },
          '#withInsecure':: d.fn(help='', args=[d.arg(name='insecure', type=d.T.boolean)]),
          withInsecure(insecure): { template+: { k8s+: { source+: { s3+: { insecure: insecure } } } } },
          '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
          withMetadata(metadata): { template+: { k8s+: { source+: { s3+: { metadata: metadata } } } } },
          '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
          withMetadataMixin(metadata): { template+: { k8s+: { source+: { s3+: { metadata+: metadata } } } } },
          '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
          withRegion(region): { template+: { k8s+: { source+: { s3+: { region: region } } } } },
        },
        '#url':: d.obj(help='"URLArtifact contains information about an artifact at an http endpoint."'),
        url: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { template+: { k8s+: { source+: { url+: { path: path } } } } },
          '#withVerifyCert':: d.fn(help='', args=[d.arg(name='verifyCert', type=d.T.boolean)]),
          withVerifyCert(verifyCert): { template+: { k8s+: { source+: { url+: { verifyCert: verifyCert } } } } },
        },
        '#withInline':: d.fn(help='', args=[d.arg(name='inline', type=d.T.string)]),
        withInline(inline): { template+: { k8s+: { source+: { inline: inline } } } },
      },
      '#withLiveObject':: d.fn(help='', args=[d.arg(name='liveObject', type=d.T.boolean)]),
      withLiveObject(liveObject): { template+: { k8s+: { liveObject: liveObject } } },
      '#withOperation':: d.fn(help='', args=[d.arg(name='operation', type=d.T.string)]),
      withOperation(operation): { template+: { k8s+: { operation: operation } } },
      '#withParameters':: d.fn(help='"Parameters is the list of parameters that is applied to resolved K8s trigger object."', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { k8s+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='"Parameters is the list of parameters that is applied to resolved K8s trigger object."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { k8s+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPatchStrategy':: d.fn(help='', args=[d.arg(name='patchStrategy', type=d.T.string)]),
      withPatchStrategy(patchStrategy): { template+: { k8s+: { patchStrategy: patchStrategy } } },
    },
    '#kafka':: d.obj(help='"KafkaTrigger refers to the specification of the Kafka trigger."'),
    kafka: {
      '#sasl':: d.obj(help=''),
      sasl: {
        '#password':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        password: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { kafka+: { sasl+: { password+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { kafka+: { sasl+: { password+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { kafka+: { sasl+: { password+: { optional: optional } } } } },
        },
        '#user':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        user: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { kafka+: { sasl+: { user+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { kafka+: { sasl+: { user+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { kafka+: { sasl+: { user+: { optional: optional } } } } },
        },
        '#withMechanism':: d.fn(help='', args=[d.arg(name='mechanism', type=d.T.string)]),
        withMechanism(mechanism): { template+: { kafka+: { sasl+: { mechanism: mechanism } } } },
      },
      '#tls':: d.obj(help='"TLSConfig refers to TLS configuration for a client."'),
      tls: {
        '#caCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        caCertSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { kafka+: { tls+: { caCertSecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { kafka+: { tls+: { caCertSecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { kafka+: { tls+: { caCertSecret+: { optional: optional } } } } },
        },
        '#clientCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        clientCertSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { kafka+: { tls+: { clientCertSecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { kafka+: { tls+: { clientCertSecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { kafka+: { tls+: { clientCertSecret+: { optional: optional } } } } },
        },
        '#clientKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        clientKeySecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { kafka+: { tls+: { clientKeySecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { kafka+: { tls+: { clientKeySecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { kafka+: { tls+: { clientKeySecret+: { optional: optional } } } } },
        },
        '#withCaCertPath':: d.fn(help='', args=[d.arg(name='caCertPath', type=d.T.string)]),
        withCaCertPath(caCertPath): { template+: { kafka+: { tls+: { caCertPath: caCertPath } } } },
        '#withClientCertPath':: d.fn(help='', args=[d.arg(name='clientCertPath', type=d.T.string)]),
        withClientCertPath(clientCertPath): { template+: { kafka+: { tls+: { clientCertPath: clientCertPath } } } },
        '#withClientKeyPath':: d.fn(help='', args=[d.arg(name='clientKeyPath', type=d.T.string)]),
        withClientKeyPath(clientKeyPath): { template+: { kafka+: { tls+: { clientKeyPath: clientKeyPath } } } },
      },
      '#withCompress':: d.fn(help='', args=[d.arg(name='compress', type=d.T.boolean)]),
      withCompress(compress): { template+: { kafka+: { compress: compress } } },
      '#withFlushFrequency':: d.fn(help='', args=[d.arg(name='flushFrequency', type=d.T.integer)]),
      withFlushFrequency(flushFrequency): { template+: { kafka+: { flushFrequency: flushFrequency } } },
      '#withParameters':: d.fn(help='"Parameters is the list of parameters that is applied to resolved Kafka trigger object."', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { kafka+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='"Parameters is the list of parameters that is applied to resolved Kafka trigger object."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { kafka+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPartition':: d.fn(help='"Partition to write data to."', args=[d.arg(name='partition', type=d.T.integer)]),
      withPartition(partition): { template+: { kafka+: { partition: partition } } },
      '#withPartitioningKey':: d.fn(help='"The partitioning key for the messages put on the Kafka topic.\\nDefaults to broker url.\\n+optional."', args=[d.arg(name='partitioningKey', type=d.T.string)]),
      withPartitioningKey(partitioningKey): { template+: { kafka+: { partitioningKey: partitioningKey } } },
      '#withPayload':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { kafka+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { kafka+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
      '#withRequiredAcks':: d.fn(help='"RequiredAcks used in producer to tell the broker how many replica acknowledgements\\nDefaults to 1 (Only wait for the leader to ack).\\n+optional."', args=[d.arg(name='requiredAcks', type=d.T.integer)]),
      withRequiredAcks(requiredAcks): { template+: { kafka+: { requiredAcks: requiredAcks } } },
      '#withTopic':: d.fn(help='', args=[d.arg(name='topic', type=d.T.string)]),
      withTopic(topic): { template+: { kafka+: { topic: topic } } },
      '#withUrl':: d.fn(help='"URL of the Kafka broker, multiple URLs separated by comma."', args=[d.arg(name='url', type=d.T.string)]),
      withUrl(url): { template+: { kafka+: { url: url } } },
      '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
      withVersion(version): { template+: { kafka+: { version: version } } },
    },
    '#log':: d.obj(help=''),
    log: {
      '#withIntervalSeconds':: d.fn(help='', args=[d.arg(name='intervalSeconds', type=d.T.string)]),
      withIntervalSeconds(intervalSeconds): { template+: { log+: { intervalSeconds: intervalSeconds } } },
    },
    '#nats':: d.obj(help='"NATSTrigger refers to the specification of the NATS trigger."'),
    nats: {
      '#tls':: d.obj(help='"TLSConfig refers to TLS configuration for a client."'),
      tls: {
        '#caCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        caCertSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { nats+: { tls+: { caCertSecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { nats+: { tls+: { caCertSecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { nats+: { tls+: { caCertSecret+: { optional: optional } } } } },
        },
        '#clientCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        clientCertSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { nats+: { tls+: { clientCertSecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { nats+: { tls+: { clientCertSecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { nats+: { tls+: { clientCertSecret+: { optional: optional } } } } },
        },
        '#clientKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        clientKeySecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { template+: { nats+: { tls+: { clientKeySecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { template+: { nats+: { tls+: { clientKeySecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { template+: { nats+: { tls+: { clientKeySecret+: { optional: optional } } } } },
        },
        '#withCaCertPath':: d.fn(help='', args=[d.arg(name='caCertPath', type=d.T.string)]),
        withCaCertPath(caCertPath): { template+: { nats+: { tls+: { caCertPath: caCertPath } } } },
        '#withClientCertPath':: d.fn(help='', args=[d.arg(name='clientCertPath', type=d.T.string)]),
        withClientCertPath(clientCertPath): { template+: { nats+: { tls+: { clientCertPath: clientCertPath } } } },
        '#withClientKeyPath':: d.fn(help='', args=[d.arg(name='clientKeyPath', type=d.T.string)]),
        withClientKeyPath(clientKeyPath): { template+: { nats+: { tls+: { clientKeyPath: clientKeyPath } } } },
      },
      '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { nats+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { nats+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPayload':: d.fn(help='', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { nats+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { nats+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
      '#withSubject':: d.fn(help='"Name of the subject to put message on."', args=[d.arg(name='subject', type=d.T.string)]),
      withSubject(subject): { template+: { nats+: { subject: subject } } },
      '#withUrl':: d.fn(help='"URL of the NATS cluster."', args=[d.arg(name='url', type=d.T.string)]),
      withUrl(url): { template+: { nats+: { url: url } } },
    },
    '#openWhisk':: d.obj(help='"OpenWhiskTrigger refers to the specification of the OpenWhisk trigger."'),
    openWhisk: {
      '#authToken':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      authToken: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { openWhisk+: { authToken+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { openWhisk+: { authToken+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { openWhisk+: { authToken+: { optional: optional } } } },
      },
      '#withActionName':: d.fn(help='"Name of the action/function."', args=[d.arg(name='actionName', type=d.T.string)]),
      withActionName(actionName): { template+: { openWhisk+: { actionName: actionName } } },
      '#withHost':: d.fn(help='"Host URL of the OpenWhisk."', args=[d.arg(name='host', type=d.T.string)]),
      withHost(host): { template+: { openWhisk+: { host: host } } },
      '#withNamespace':: d.fn(help='"Namespace for the action.\\nDefaults to \\"_\\".\\n+optional."', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { template+: { openWhisk+: { namespace: namespace } } },
      '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { openWhisk+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { openWhisk+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withPayload':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."', args=[d.arg(name='payload', type=d.T.array)]),
      withPayload(payload): { template+: { openWhisk+: { payload: if std.isArray(v=payload) then payload else [payload] } } },
      '#withPayloadMixin':: d.fn(help='"Payload is the list of key-value extracted from an event payload to construct the request payload."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='payload', type=d.T.array)]),
      withPayloadMixin(payload): { template+: { openWhisk+: { payload+: if std.isArray(v=payload) then payload else [payload] } } },
      '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
      withVersion(version): { template+: { openWhisk+: { version: version } } },
    },
    '#slack':: d.obj(help='"SlackTrigger refers to the specification of the slack notification trigger."'),
    slack: {
      '#slackToken':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      slackToken: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { template+: { slack+: { slackToken+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { template+: { slack+: { slackToken+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { template+: { slack+: { slackToken+: { optional: optional } } } },
      },
      '#withChannel':: d.fn(help='', args=[d.arg(name='channel', type=d.T.string)]),
      withChannel(channel): { template+: { slack+: { channel: channel } } },
      '#withMessage':: d.fn(help='', args=[d.arg(name='message', type=d.T.string)]),
      withMessage(message): { template+: { slack+: { message: message } } },
      '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { template+: { slack+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { template+: { slack+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
    },
    '#switch':: d.obj(help=''),
    switch: {
      '#withAll':: d.fn(help='', args=[d.arg(name='all', type=d.T.array)]),
      withAll(all): { template+: { switch+: { all: if std.isArray(v=all) then all else [all] } } },
      '#withAllMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='all', type=d.T.array)]),
      withAllMixin(all): { template+: { switch+: { all+: if std.isArray(v=all) then all else [all] } } },
      '#withAny':: d.fn(help='', args=[d.arg(name='any', type=d.T.array)]),
      withAny(any): { template+: { switch+: { any: if std.isArray(v=any) then any else [any] } } },
      '#withAnyMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='any', type=d.T.array)]),
      withAnyMixin(any): { template+: { switch+: { any+: if std.isArray(v=any) then any else [any] } } },
    },
    '#withConditions':: d.fn(help='', args=[d.arg(name='conditions', type=d.T.string)]),
    withConditions(conditions): { template+: { conditions: conditions } },
    '#withName':: d.fn(help='"Name is a unique name of the action to take."', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { template+: { name: name } },
  },
  '#withParameters':: d.fn(help='', args=[d.arg(name='parameters', type=d.T.array)]),
  withParameters(parameters): { parameters: if std.isArray(v=parameters) then parameters else [parameters] },
  '#withParametersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
  withParametersMixin(parameters): { parameters+: if std.isArray(v=parameters) then parameters else [parameters] },
  '#mixin': 'ignore',
  mixin: self,
}

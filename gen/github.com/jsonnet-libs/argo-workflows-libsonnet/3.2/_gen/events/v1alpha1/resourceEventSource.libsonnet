{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='resourceEventSource', url='', help='"ResourceEventSource refers to a event-source for K8s resource related events."'),
  '#filter':: d.obj(help=''),
  filter: {
    '#withAfterStart':: d.fn(help='', args=[d.arg(name='afterStart', type=d.T.boolean)]),
    withAfterStart(afterStart): { filter+: { afterStart: afterStart } },
    '#withCreatedBy':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='createdBy', type=d.T.string)]),
    withCreatedBy(createdBy): { filter+: { createdBy: createdBy } },
    '#withFields':: d.fn(help='', args=[d.arg(name='fields', type=d.T.array)]),
    withFields(fields): { filter+: { fields: if std.isArray(v=fields) then fields else [fields] } },
    '#withFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fields', type=d.T.array)]),
    withFieldsMixin(fields): { filter+: { fields+: if std.isArray(v=fields) then fields else [fields] } },
    '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.array)]),
    withLabels(labels): { filter+: { labels: if std.isArray(v=labels) then labels else [labels] } },
    '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.array)]),
    withLabelsMixin(labels): { filter+: { labels+: if std.isArray(v=labels) then labels else [labels] } },
    '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
    withPrefix(prefix): { filter+: { prefix: prefix } },
  },
  '#groupVersionResource':: d.obj(help='"+protobuf.options.(gogoproto.goproto_stringer)=false"'),
  groupVersionResource: {
    '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
    withGroup(group): { groupVersionResource+: { group: group } },
    '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
    withResource(resource): { groupVersionResource+: { resource: resource } },
    '#withVersion':: d.fn(help='', args=[d.arg(name='version', type=d.T.string)]),
    withVersion(version): { groupVersionResource+: { version: version } },
  },
  '#withEventTypes':: d.fn(help='"EventTypes is the list of event type to watch.\\nPossible values are - ADD, UPDATE and DELETE."', args=[d.arg(name='eventTypes', type=d.T.array)]),
  withEventTypes(eventTypes): { eventTypes: if std.isArray(v=eventTypes) then eventTypes else [eventTypes] },
  '#withEventTypesMixin':: d.fn(help='"EventTypes is the list of event type to watch.\\nPossible values are - ADD, UPDATE and DELETE."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='eventTypes', type=d.T.array)]),
  withEventTypesMixin(eventTypes): { eventTypes+: if std.isArray(v=eventTypes) then eventTypes else [eventTypes] },
  '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
  withMetadata(metadata): { metadata: metadata },
  '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
  withMetadataMixin(metadata): { metadata+: metadata },
  '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
  withNamespace(namespace): { namespace: namespace },
  '#mixin': 'ignore',
  mixin: self,
}

{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='instance', url='', help='"Instance is a managed resource that represents a specified number of AWS EC2 Instance"'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Instance', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'Instance',
  } + self.metadata.withName(name=name) + self.metadata.withAnnotations(annotations={
    'tanka.dev/namespaced': 'false',
  }),
  '#spec':: d.obj(help='"An InstanceSpec defines the desired state of Instances."'),
  spec: {
    '#forProvider':: d.obj(help='"InstanceParameters define the desired state of the Instances"'),
    forProvider: {
      '#blockDeviceMappings':: d.obj(help='"The block device mapping entries."'),
      blockDeviceMappings: {
        '#ebs':: d.obj(help='"Parameters used to automatically set up EBS volumes when the instance is launched."'),
        ebs: {
          '#kmsKeyIdRef':: d.obj(help='"KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID."'),
          kmsKeyIdRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { ebs+: { kmsKeyIdRef+: { policy+: { resolution: resolution } } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { ebs+: { kmsKeyIdRef+: { policy+: { resolve: resolve } } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { ebs+: { kmsKeyIdRef+: { name: name } } },
          },
          '#kmsKeyIdSelector':: d.obj(help='"KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID."'),
          kmsKeyIdSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { ebs+: { kmsKeyIdSelector+: { policy+: { resolution: resolution } } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { ebs+: { kmsKeyIdSelector+: { policy+: { resolve: resolve } } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { ebs+: { kmsKeyIdSelector+: { matchControllerRef: matchControllerRef } } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { ebs+: { kmsKeyIdSelector+: { matchLabels: matchLabels } } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { ebs+: { kmsKeyIdSelector+: { matchLabels+: matchLabels } } },
          },
          '#withDeleteOnTermination':: d.fn(help='"Indicates whether the EBS volume is deleted on instance termination. For more information, see Preserving Amazon EBS Volumes on Instance Termination (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the Amazon Elastic Compute Cloud User Guide."', args=[d.arg(name='deleteOnTermination', type=d.T.boolean)]),
          withDeleteOnTermination(deleteOnTermination): { ebs+: { deleteOnTermination: deleteOnTermination } },
          '#withEncrypted':: d.fn(help='"Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see Amazon EBS Encryption (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the Amazon Elastic Compute Cloud User Guide. \\n In no case can you remove encryption from an encrypted volume. \\n Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see Supported Instance Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances). \\n This parameter is not returned by ."', args=[d.arg(name='encrypted', type=d.T.boolean)]),
          withEncrypted(encrypted): { ebs+: { encrypted: encrypted } },
          '#withIops':: d.fn(help='"The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information, see Amazon EBS Volume Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the Amazon Elastic Compute Cloud User Guide. \\n Constraints: Range is 100-16,000 IOPS for gp2 volumes and 100 to 64,000IOPS for io1 volumes in most Regions. Maximum io1 IOPS of 64,000 is guaranteed only on Nitro-based instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). Other instance families guarantee performance up to 32,000 IOPS. For more information, see Amazon EBS Volume Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the Amazon Elastic Compute Cloud User Guide. \\n Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes."', args=[d.arg(name='iops', type=d.T.integer)]),
          withIops(iops): { ebs+: { iops: iops } },
          '#withKmsKeyId':: d.fn(help='"Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted. \\n This parameter is only supported on BlockDeviceMapping objects called by RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html), RequestSpotFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html), and RequestSpotInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html)."', args=[d.arg(name='kmsKeyId', type=d.T.string)]),
          withKmsKeyId(kmsKeyId): { ebs+: { kmsKeyId: kmsKeyId } },
          '#withSnapshotId':: d.fn(help='"The ID of the snapshot."', args=[d.arg(name='snapshotId', type=d.T.string)]),
          withSnapshotId(snapshotId): { ebs+: { snapshotId: snapshotId } },
          '#withVolumeSize':: d.fn(help="\"The size of the volume, in GiB. \\n Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size. \\n Constraints: 1-16384 for General Purpose SSD (gp2), 4-16384 for Provisioned IOPS SSD (io1), 500-16384 for Throughput Optimized HDD (st1), 500-16384 for Cold HDD (sc1), and 1-1024 for Magnetic (standard) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.\"", args=[d.arg(name='volumeSize', type=d.T.integer)]),
          withVolumeSize(volumeSize): { ebs+: { volumeSize: volumeSize } },
          '#withVolumeType':: d.fn(help='"The volume type. If you set the type to io1, you must also specify the Iops parameter. If you set the type to gp2, st1, sc1, or standard, you must omit the Iops parameter. \\n Default: gp2"', args=[d.arg(name='volumeType', type=d.T.string)]),
          withVolumeType(volumeType): { ebs+: { volumeType: volumeType } },
        },
        '#withDeviceName':: d.fn(help='"The device name (for example, /dev/sdh or xvdh)."', args=[d.arg(name='deviceName', type=d.T.string)]),
        withDeviceName(deviceName): { deviceName: deviceName },
        '#withNoDevice':: d.fn(help='"Suppresses the specified device included in the block device mapping of the AMI."', args=[d.arg(name='noDevice', type=d.T.string)]),
        withNoDevice(noDevice): { noDevice: noDevice },
        '#withVirtualName':: d.fn(help='"The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. \\n NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. \\n Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI."', args=[d.arg(name='virtualName', type=d.T.string)]),
        withVirtualName(virtualName): { virtualName: virtualName },
      },
      '#capacityReservationSpecification':: d.obj(help="\"Information about the Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to open, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).\""),
      capacityReservationSpecification: {
        '#capacityReservationTarget':: d.obj(help='"Information about the target Capacity Reservation."'),
        capacityReservationTarget: {
          '#withCapacityReservationId':: d.fn(help='"The ID of the Capacity Reservation."', args=[d.arg(name='capacityReservationId', type=d.T.string)]),
          withCapacityReservationId(capacityReservationId): { spec+: { forProvider+: { capacityReservationSpecification+: { capacityReservationTarget+: { capacityReservationId: capacityReservationId } } } } },
        },
        '#withCapacityReservationsPreference':: d.fn(help="\"Indicates the instance's Capacity Reservation preferences. Possible preferences include: \\n * open - The instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). \\n * none - The instance avoids running in a Capacity Reservation even if one is available. The instance runs as an On-Demand Instance.\"", args=[d.arg(name='capacityReservationsPreference', type=d.T.string)]),
        withCapacityReservationsPreference(capacityReservationsPreference): { spec+: { forProvider+: { capacityReservationSpecification+: { capacityReservationsPreference: capacityReservationsPreference } } } },
      },
      '#cpuOptions':: d.obj(help='"The CPU options for the instance. For more information, see Optimizing CPU Options (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide."'),
      cpuOptions: {
        '#withCoreCount':: d.fn(help='"The number of CPU cores for the instance."', args=[d.arg(name='coreCount', type=d.T.integer)]),
        withCoreCount(coreCount): { spec+: { forProvider+: { cpuOptions+: { coreCount: coreCount } } } },
        '#withThreadsPerCore':: d.fn(help='"The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2."', args=[d.arg(name='threadsPerCore', type=d.T.integer)]),
        withThreadsPerCore(threadsPerCore): { spec+: { forProvider+: { cpuOptions+: { threadsPerCore: threadsPerCore } } } },
      },
      '#creditSpecification':: d.obj(help='"The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited. To change this attribute after launch, use ModifyInstanceCreditSpecification (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html). For more information, see Burstable Performance Instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the Amazon Elastic Compute Cloud User Guide. \\n Default: standard (T2 instances) or unlimited (T3/T3a instances)"'),
      creditSpecification: {
        '#withCpuCredits':: d.fn(help='"The credit option for CPU usage of a T2 or T3 instance. Valid values are standard and unlimited. \\n CPUCredits is a required field"', args=[d.arg(name='cpuCredits', type=d.T.string)]),
        withCpuCredits(cpuCredits): { spec+: { forProvider+: { creditSpecification+: { cpuCredits: cpuCredits } } } },
      },
      '#elasticGpuSpecification':: d.obj(help='"An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see Amazon EC2 Elastic GPUs (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the Amazon Elastic Compute Cloud User Guide."'),
      elasticGpuSpecification: {
        '#withType':: d.fn(help='"The type of Elastic Graphics accelerator. For more information about the values to specify for Type, see Elastic Graphics Basics (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics), specifically the Elastic Graphics accelerator column, in the Amazon Elastic Compute Cloud User Guide for Windows Instances. \\n Type is a required field"', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { type: type },
      },
      '#elasticInferenceAccelerators':: d.obj(help='"An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. \\n You cannot specify accelerators from different generations in the same request."'),
      elasticInferenceAccelerators: {
        '#withCount':: d.fn(help='"The number of elastic inference accelerators to attach to the instance. \\n Default: 1"', args=[d.arg(name='count', type=d.T.integer)]),
        withCount(count): { count: count },
        '#withType':: d.fn(help='"The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge. \\n Type is a required field"', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { type: type },
      },
      '#hibernationOptions':: d.obj(help='"Indicates whether an instance is enabled for hibernation. For more information, see Hibernate Your Instance (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the Amazon Elastic Compute Cloud User Guide."'),
      hibernationOptions: {
        '#withConfigured':: d.fn(help='"If you set this parameter to true, your instance is enabled for hibernation. \\n Default: false"', args=[d.arg(name='configured', type=d.T.boolean)]),
        withConfigured(configured): { spec+: { forProvider+: { hibernationOptions+: { configured: configured } } } },
      },
      '#iamInstanceProfile':: d.obj(help='"The IAM instance profile."'),
      iamInstanceProfile: {
        '#withArn':: d.fn(help='"The Amazon Resource Name (ARN) of the instance profile."', args=[d.arg(name='arn', type=d.T.string)]),
        withArn(arn): { spec+: { forProvider+: { iamInstanceProfile+: { arn: arn } } } },
        '#withName':: d.fn(help='"The name of the instance profile."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { iamInstanceProfile+: { name: name } } } },
      },
      '#instanceMarketOptions':: d.obj(help='"The market (purchasing) option for the instances. \\n For RunInstances, persistent Spot Instance requests are only supported when InstanceInterruptionBehavior is set to either hibernate or stop."'),
      instanceMarketOptions: {
        '#spotOptions':: d.obj(help='"The options for Spot Instances."'),
        spotOptions: {
          '#withBlockDurationMinutes':: d.fn(help='"The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360)."', args=[d.arg(name='blockDurationMinutes', type=d.T.integer)]),
          withBlockDurationMinutes(blockDurationMinutes): { spec+: { forProvider+: { instanceMarketOptions+: { spotOptions+: { blockDurationMinutes: blockDurationMinutes } } } } },
          '#withInstanceInterruptionBehavior':: d.fn(help='"The behavior when a Spot Instance is interrupted. The default is terminate."', args=[d.arg(name='instanceInterruptionBehavior', type=d.T.string)]),
          withInstanceInterruptionBehavior(instanceInterruptionBehavior): { spec+: { forProvider+: { instanceMarketOptions+: { spotOptions+: { instanceInterruptionBehavior: instanceInterruptionBehavior } } } } },
          '#withMaxPrice':: d.fn(help="\"The maximum hourly price you're willing to pay for the Spot Instances. The default is the On-Demand price.\"", args=[d.arg(name='maxPrice', type=d.T.string)]),
          withMaxPrice(maxPrice): { spec+: { forProvider+: { instanceMarketOptions+: { spotOptions+: { maxPrice: maxPrice } } } } },
          '#withSpotInstanceType':: d.fn(help='"The Spot Instance request type. For RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances), persistent Spot Instance requests are only supported when InstanceInterruptionBehavior is set to either hibernate or stop."', args=[d.arg(name='spotInstanceType', type=d.T.string)]),
          withSpotInstanceType(spotInstanceType): { spec+: { forProvider+: { instanceMarketOptions+: { spotOptions+: { spotInstanceType: spotInstanceType } } } } },
          '#withValidUntil':: d.fn(help='"The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date. Must be in UTC format (YYYY-MM-DDTHH:MM:SSZ)"', args=[d.arg(name='validUntil', type=d.T.string)]),
          withValidUntil(validUntil): { spec+: { forProvider+: { instanceMarketOptions+: { spotOptions+: { validUntil: validUntil } } } } },
        },
        '#withMarketType':: d.fn(help='"The market type."', args=[d.arg(name='marketType', type=d.T.string)]),
        withMarketType(marketType): { spec+: { forProvider+: { instanceMarketOptions+: { marketType: marketType } } } },
      },
      '#ipv6Addresses':: d.obj(help="\"[EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. \\n You cannot specify this option and the network interfaces option in the same request.\""),
      ipv6Addresses: {
        '#withIpv6Address':: d.fn(help='"The IPv6 address."', args=[d.arg(name='ipv6Address', type=d.T.string)]),
        withIpv6Address(ipv6Address): { ipv6Address: ipv6Address },
      },
      '#launchTemplate':: d.obj(help='"The launch template to use to launch the instances. Any parameters that you specify in RunInstances override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both."'),
      launchTemplate: {
        '#withLaunchTemplateId':: d.fn(help='"The ID of the launch template."', args=[d.arg(name='launchTemplateId', type=d.T.string)]),
        withLaunchTemplateId(launchTemplateId): { spec+: { forProvider+: { launchTemplate+: { launchTemplateId: launchTemplateId } } } },
        '#withLaunchTemplateName':: d.fn(help='"The name of the launch template."', args=[d.arg(name='launchTemplateName', type=d.T.string)]),
        withLaunchTemplateName(launchTemplateName): { spec+: { forProvider+: { launchTemplate+: { launchTemplateName: launchTemplateName } } } },
        '#withVersion':: d.fn(help='"The version number of the launch template. \\n Default: The default version for the launch template."', args=[d.arg(name='version', type=d.T.string)]),
        withVersion(version): { spec+: { forProvider+: { launchTemplate+: { version: version } } } },
      },
      '#licenseSpecifications':: d.obj(help='"The Amazon Resource Name (ARN) of the license configuration"'),
      licenseSpecifications: {
        '#withLicenseConfigurationArn':: d.fn(help='"Amazon Resource Name (ARN) of the license configuration"', args=[d.arg(name='licenseConfigurationArn', type=d.T.string)]),
        withLicenseConfigurationArn(licenseConfigurationArn): { licenseConfigurationArn: licenseConfigurationArn },
      },
      '#metadataOptions':: d.obj(help='"The metadata options for the instance. For more information, see Instance Metadata and User Data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)."'),
      metadataOptions: {
        '#withHttpEndpoint':: d.fn(help='"This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled. \\n If you specify a value of disabled, you will not be able to access your instance metadata."', args=[d.arg(name='httpEndpoint', type=d.T.string)]),
        withHttpEndpoint(httpEndpoint): { spec+: { forProvider+: { metadataOptions+: { httpEndpoint: httpEndpoint } } } },
        '#withHttpPutResponseHopLimit':: d.fn(help='"The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. \\n Default: 1 \\n Possible values: Integers from 1 to 64"', args=[d.arg(name='httpPutResponseHopLimit', type=d.T.integer)]),
        withHttpPutResponseHopLimit(httpPutResponseHopLimit): { spec+: { forProvider+: { metadataOptions+: { httpPutResponseHopLimit: httpPutResponseHopLimit } } } },
        '#withHttpTokens':: d.fn(help='"The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is optional. \\n If the state is optional, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned. \\n If the state is required, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available."', args=[d.arg(name='httpTokens', type=d.T.string)]),
        withHttpTokens(httpTokens): { spec+: { forProvider+: { metadataOptions+: { httpTokens: httpTokens } } } },
      },
      '#monitoring':: d.obj(help='"Specifies whether detailed monitoring is enabled for the instance."'),
      monitoring: {
        '#withEnabled':: d.fn(help='"Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled. \\n Enabled is a required field"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { forProvider+: { monitoring+: { enabled: enabled } } } },
      },
      '#networkInterfaces':: d.obj(help='"The network interfaces to associate with the instance. If you specify a network interface, you must specify any security groups and subnets as part of the network interface."'),
      networkInterfaces: {
        '#ipv6Addresses':: d.obj(help="\"One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.\""),
        ipv6Addresses: {
          '#withIpv6Address':: d.fn(help='"The IPv6 address."', args=[d.arg(name='ipv6Address', type=d.T.string)]),
          withIpv6Address(ipv6Address): { ipv6Address: ipv6Address },
        },
        '#privateIpAddresses':: d.obj(help="\"One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.\""),
        privateIpAddresses: {
          '#withPrimary':: d.fn(help='"Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary."', args=[d.arg(name='primary', type=d.T.boolean)]),
          withPrimary(primary): { primary: primary },
          '#withPrivateIPAddress':: d.fn(help='"The private IPv4 addresses."', args=[d.arg(name='privateIPAddress', type=d.T.string)]),
          withPrivateIPAddress(privateIPAddress): { privateIPAddress: privateIPAddress },
        },
        '#withAssociatePublicIpAddress':: d.fn(help='"Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true."', args=[d.arg(name='associatePublicIpAddress', type=d.T.boolean)]),
        withAssociatePublicIpAddress(associatePublicIpAddress): { associatePublicIpAddress: associatePublicIpAddress },
        '#withDeleteOnTermination':: d.fn(help='"If set to true, the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance."', args=[d.arg(name='deleteOnTermination', type=d.T.boolean)]),
        withDeleteOnTermination(deleteOnTermination): { deleteOnTermination: deleteOnTermination },
        '#withDescription':: d.fn(help='"The description of the network interface. Applies only if creating a network interface when launching an instance."', args=[d.arg(name='description', type=d.T.string)]),
        withDescription(description): { description: description },
        '#withDeviceIndex':: d.fn(help='"The position of the network interface in the attachment order. A primary network interface has a device index of 0. \\n If you specify a network interface when launching an instance, you must specify the device index."', args=[d.arg(name='deviceIndex', type=d.T.integer)]),
        withDeviceIndex(deviceIndex): { deviceIndex: deviceIndex },
        '#withGroups':: d.fn(help='"The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance."', args=[d.arg(name='groups', type=d.T.array)]),
        withGroups(groups): { groups: if std.isArray(v=groups) then groups else [groups] },
        '#withGroupsMixin':: d.fn(help='"The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groups', type=d.T.array)]),
        withGroupsMixin(groups): { groups+: if std.isArray(v=groups) then groups else [groups] },
        '#withInterfaceType':: d.fn(help='"The type of network interface. To create an Elastic Fabric Adapter (EFA), specify efa. For more information, see Elastic Fabric Adapter (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the Amazon Elastic Compute Cloud User Guide. \\n If you are not creating an EFA, specify interface or omit this parameter. \\n Valid values: interface | efa"', args=[d.arg(name='interfaceType', type=d.T.string)]),
        withInterfaceType(interfaceType): { interfaceType: interfaceType },
        '#withIpv6AddressCount':: d.fn(help="\"A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.\"", args=[d.arg(name='ipv6AddressCount', type=d.T.integer)]),
        withIpv6AddressCount(ipv6AddressCount): { ipv6AddressCount: ipv6AddressCount },
        '#withIpv6Addresses':: d.fn(help="\"One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.\"", args=[d.arg(name='ipv6Addresses', type=d.T.array)]),
        withIpv6Addresses(ipv6Addresses): { ipv6Addresses: if std.isArray(v=ipv6Addresses) then ipv6Addresses else [ipv6Addresses] },
        '#withIpv6AddressesMixin':: d.fn(help="\"One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='ipv6Addresses', type=d.T.array)]),
        withIpv6AddressesMixin(ipv6Addresses): { ipv6Addresses+: if std.isArray(v=ipv6Addresses) then ipv6Addresses else [ipv6Addresses] },
        '#withNetworkInterfaceId':: d.fn(help='"The ID of the network interface. \\n If you are creating a Spot Fleet, omit this parameter because you canâ€™t specify a network interface ID in a launch specification."', args=[d.arg(name='networkInterfaceId', type=d.T.string)]),
        withNetworkInterfaceId(networkInterfaceId): { networkInterfaceId: networkInterfaceId },
        '#withPrivateIpAddress':: d.fn(help="\"The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.\"", args=[d.arg(name='privateIpAddress', type=d.T.string)]),
        withPrivateIpAddress(privateIpAddress): { privateIpAddress: privateIpAddress },
        '#withPrivateIpAddresses':: d.fn(help="\"One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.\"", args=[d.arg(name='privateIpAddresses', type=d.T.array)]),
        withPrivateIpAddresses(privateIpAddresses): { privateIpAddresses: if std.isArray(v=privateIpAddresses) then privateIpAddresses else [privateIpAddresses] },
        '#withPrivateIpAddressesMixin':: d.fn(help="\"One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='privateIpAddresses', type=d.T.array)]),
        withPrivateIpAddressesMixin(privateIpAddresses): { privateIpAddresses+: if std.isArray(v=privateIpAddresses) then privateIpAddresses else [privateIpAddresses] },
        '#withSecondaryPrivateIpAddressCount':: d.fn(help="\"The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.\"", args=[d.arg(name='secondaryPrivateIpAddressCount', type=d.T.integer)]),
        withSecondaryPrivateIpAddressCount(secondaryPrivateIpAddressCount): { secondaryPrivateIpAddressCount: secondaryPrivateIpAddressCount },
        '#withSubnetId':: d.fn(help='"The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance."', args=[d.arg(name='subnetId', type=d.T.string)]),
        withSubnetId(subnetId): { subnetId: subnetId },
      },
      '#placement':: d.obj(help='"The placement for the instance."'),
      placement: {
        '#withAffinity':: d.fn(help='"The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the ImportInstance (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) command. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='affinity', type=d.T.string)]),
        withAffinity(affinity): { spec+: { forProvider+: { placement+: { affinity: affinity } } } },
        '#withAvailabilityZone':: d.fn(help='"The Availability Zone of the instance. \\n If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='availabilityZone', type=d.T.string)]),
        withAvailabilityZone(availabilityZone): { spec+: { forProvider+: { placement+: { availabilityZone: availabilityZone } } } },
        '#withGroupName':: d.fn(help='"The name of the placement group the instance is in."', args=[d.arg(name='groupName', type=d.T.string)]),
        withGroupName(groupName): { spec+: { forProvider+: { placement+: { groupName: groupName } } } },
        '#withHostId':: d.fn(help='"The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the ImportInstance (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) command. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='hostId', type=d.T.string)]),
        withHostId(hostId): { spec+: { forProvider+: { placement+: { hostId: hostId } } } },
        '#withHostResourceGroupArn':: d.fn(help='"The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the Tenancy parameter or set it to host. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='hostResourceGroupArn', type=d.T.string)]),
        withHostResourceGroupArn(hostResourceGroupArn): { spec+: { forProvider+: { placement+: { hostResourceGroupArn: hostResourceGroupArn } } } },
        '#withPartitionNumber':: d.fn(help='"The number of the partition the instance is in. Valid only if the placement group strategy is set to partition. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='partitionNumber', type=d.T.integer)]),
        withPartitionNumber(partitionNumber): { spec+: { forProvider+: { placement+: { partitionNumber: partitionNumber } } } },
        '#withSpreadDomain':: d.fn(help='"Reserved for future use. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='spreadDomain', type=d.T.string)]),
        withSpreadDomain(spreadDomain): { spec+: { forProvider+: { placement+: { spreadDomain: spreadDomain } } } },
        '#withTenancy':: d.fn(help='"The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the ImportInstance (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) command. \\n This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet)."', args=[d.arg(name='tenancy', type=d.T.string)]),
        withTenancy(tenancy): { spec+: { forProvider+: { placement+: { tenancy: tenancy } } } },
      },
      '#securityGroupRefs':: d.obj(help='"SecurityGroupsRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs."'),
      securityGroupRefs: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { policy+: { resolution: resolution } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { policy+: { resolve: resolve } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#securityGroupSelector':: d.obj(help='"SecurityGroupsSelector selects references to SecurityGroups used to set the SecurityGroupIDs."'),
      securityGroupSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { securityGroupSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { securityGroupSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { securityGroupSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { securityGroupSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { securityGroupSelector+: { matchLabels+: matchLabels } } } },
      },
      '#subnetIdRef':: d.obj(help='"SubnetIDRef is a reference to a Subnet used to set the SubnetID."'),
      subnetIdRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { subnetIdRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { subnetIdRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { subnetIdRef+: { name: name } } } },
      },
      '#subnetIdSelector':: d.obj(help='"SubnetIDSelector selects a reference to a Subnet used to set the SubnetID."'),
      subnetIdSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { subnetIdSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { subnetIdSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { subnetIdSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { subnetIdSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { subnetIdSelector+: { matchLabels+: matchLabels } } } },
      },
      '#tagSpecifications':: d.obj(help='"The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html)."'),
      tagSpecifications: {
        '#tags':: d.obj(help='"The tags to apply to the resource"'),
        tags: {
          '#withKey':: d.fn(help='"Key is the name of the tag."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"Value is the value of the tag."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withResourceType':: d.fn(help='"The type of resource to tag. Currently, the resource types that support tagging on creation are: capacity-reservation | client-vpn-endpoint | dedicated-host | fleet | fpga-image | instance | ipv4pool-ec2 | ipv6pool-ec2 | key-pair | launch-template | natgateway | spot-fleet-request | placement-group | snapshot | traffic-mirror-filter | traffic-mirror-session | traffic-mirror-target | transit-gateway | transit-gateway-attachment | transit-gateway-route-table | vpc-endpoint (for interface VPC endpoints)| vpc-endpoint-service (for gateway VPC endpoints) | volume | vpc-flow-log. \\n To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html)."', args=[d.arg(name='resourceType', type=d.T.string)]),
        withResourceType(resourceType): { resourceType: resourceType },
        '#withTags':: d.fn(help='"The tags to apply to the resource"', args=[d.arg(name='tags', type=d.T.array)]),
        withTags(tags): { tags: if std.isArray(v=tags) then tags else [tags] },
        '#withTagsMixin':: d.fn(help='"The tags to apply to the resource"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
        withTagsMixin(tags): { tags+: if std.isArray(v=tags) then tags else [tags] },
      },
      '#tags':: d.obj(help='"Tags are used as identification helpers between AWS resources."'),
      tags: {
        '#withKey':: d.fn(help='"Key is the name of the tag."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withValue':: d.fn(help='"Value is the value of the tag."', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#withBlockDeviceMappings':: d.fn(help='"The block device mapping entries."', args=[d.arg(name='blockDeviceMappings', type=d.T.array)]),
      withBlockDeviceMappings(blockDeviceMappings): { spec+: { forProvider+: { blockDeviceMappings: if std.isArray(v=blockDeviceMappings) then blockDeviceMappings else [blockDeviceMappings] } } },
      '#withBlockDeviceMappingsMixin':: d.fn(help='"The block device mapping entries."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blockDeviceMappings', type=d.T.array)]),
      withBlockDeviceMappingsMixin(blockDeviceMappings): { spec+: { forProvider+: { blockDeviceMappings+: if std.isArray(v=blockDeviceMappings) then blockDeviceMappings else [blockDeviceMappings] } } },
      '#withClientToken':: d.fn(help='"Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency. \\n For more information, see Ensuring Idempotency (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html). \\n Constraints: Maximum 64 ASCII characters"', args=[d.arg(name='clientToken', type=d.T.string)]),
      withClientToken(clientToken): { spec+: { forProvider+: { clientToken: clientToken } } },
      '#withDisableAPITermination':: d.fn(help="\"If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use ModifyInstanceAttribute (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html). Alternatively, if you set InstanceInitiatedShutdownBehavior to terminate, you can terminate the instance by running the shutdown command from the instance. \\n Default: false\"", args=[d.arg(name='disableAPITermination', type=d.T.boolean)]),
      withDisableAPITermination(disableAPITermination): { spec+: { forProvider+: { disableAPITermination: disableAPITermination } } },
      '#withEbsOptimized':: d.fn(help="\"Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. \\n Default: false\"", args=[d.arg(name='ebsOptimized', type=d.T.boolean)]),
      withEbsOptimized(ebsOptimized): { spec+: { forProvider+: { ebsOptimized: ebsOptimized } } },
      '#withElasticGpuSpecification':: d.fn(help='"An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see Amazon EC2 Elastic GPUs (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the Amazon Elastic Compute Cloud User Guide."', args=[d.arg(name='elasticGpuSpecification', type=d.T.array)]),
      withElasticGpuSpecification(elasticGpuSpecification): { spec+: { forProvider+: { elasticGpuSpecification: if std.isArray(v=elasticGpuSpecification) then elasticGpuSpecification else [elasticGpuSpecification] } } },
      '#withElasticGpuSpecificationMixin':: d.fn(help='"An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see Amazon EC2 Elastic GPUs (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the Amazon Elastic Compute Cloud User Guide."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='elasticGpuSpecification', type=d.T.array)]),
      withElasticGpuSpecificationMixin(elasticGpuSpecification): { spec+: { forProvider+: { elasticGpuSpecification+: if std.isArray(v=elasticGpuSpecification) then elasticGpuSpecification else [elasticGpuSpecification] } } },
      '#withElasticInferenceAccelerators':: d.fn(help='"An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. \\n You cannot specify accelerators from different generations in the same request."', args=[d.arg(name='elasticInferenceAccelerators', type=d.T.array)]),
      withElasticInferenceAccelerators(elasticInferenceAccelerators): { spec+: { forProvider+: { elasticInferenceAccelerators: if std.isArray(v=elasticInferenceAccelerators) then elasticInferenceAccelerators else [elasticInferenceAccelerators] } } },
      '#withElasticInferenceAcceleratorsMixin':: d.fn(help='"An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. \\n You cannot specify accelerators from different generations in the same request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='elasticInferenceAccelerators', type=d.T.array)]),
      withElasticInferenceAcceleratorsMixin(elasticInferenceAccelerators): { spec+: { forProvider+: { elasticInferenceAccelerators+: if std.isArray(v=elasticInferenceAccelerators) then elasticInferenceAccelerators else [elasticInferenceAccelerators] } } },
      '#withImageId':: d.fn(help='"The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template."', args=[d.arg(name='imageId', type=d.T.string)]),
      withImageId(imageId): { spec+: { forProvider+: { imageId: imageId } } },
      '#withInstanceInitiatedShutdownBehavior':: d.fn(help='"Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). \\n Default: stop"', args=[d.arg(name='instanceInitiatedShutdownBehavior', type=d.T.string)]),
      withInstanceInitiatedShutdownBehavior(instanceInitiatedShutdownBehavior): { spec+: { forProvider+: { instanceInitiatedShutdownBehavior: instanceInitiatedShutdownBehavior } } },
      '#withInstanceType':: d.fn(help='"The instance type. For more information, see Instance Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the Amazon Elastic Compute Cloud User Guide. \\n Default: m1.small"', args=[d.arg(name='instanceType', type=d.T.string)]),
      withInstanceType(instanceType): { spec+: { forProvider+: { instanceType: instanceType } } },
      '#withIpv6AddressCount':: d.fn(help="\"[EC2-VPC] The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. \\n You cannot specify this option and the network interfaces option in the same request.\"", args=[d.arg(name='ipv6AddressCount', type=d.T.integer)]),
      withIpv6AddressCount(ipv6AddressCount): { spec+: { forProvider+: { ipv6AddressCount: ipv6AddressCount } } },
      '#withIpv6Addresses':: d.fn(help="\"[EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. \\n You cannot specify this option and the network interfaces option in the same request.\"", args=[d.arg(name='ipv6Addresses', type=d.T.array)]),
      withIpv6Addresses(ipv6Addresses): { spec+: { forProvider+: { ipv6Addresses: if std.isArray(v=ipv6Addresses) then ipv6Addresses else [ipv6Addresses] } } },
      '#withIpv6AddressesMixin':: d.fn(help="\"[EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. \\n You cannot specify this option and the network interfaces option in the same request.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='ipv6Addresses', type=d.T.array)]),
      withIpv6AddressesMixin(ipv6Addresses): { spec+: { forProvider+: { ipv6Addresses+: if std.isArray(v=ipv6Addresses) then ipv6Addresses else [ipv6Addresses] } } },
      '#withKernelId':: d.fn(help='"The ID of the kernel. \\n AWS recommends that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the Amazon Elastic Compute Cloud User Guide."', args=[d.arg(name='kernelId', type=d.T.string)]),
      withKernelId(kernelId): { spec+: { forProvider+: { kernelId: kernelId } } },
      '#withKeyName':: d.fn(help="\"The name of the key pair. You can create a key pair using CreateKeyPair (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or ImportKeyPair (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html). \\n If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.\"", args=[d.arg(name='keyName', type=d.T.string)]),
      withKeyName(keyName): { spec+: { forProvider+: { keyName: keyName } } },
      '#withLicenseSpecifications':: d.fn(help='"The Amazon Resource Name (ARN) of the license configuration"', args=[d.arg(name='licenseSpecifications', type=d.T.array)]),
      withLicenseSpecifications(licenseSpecifications): { spec+: { forProvider+: { licenseSpecifications: if std.isArray(v=licenseSpecifications) then licenseSpecifications else [licenseSpecifications] } } },
      '#withLicenseSpecificationsMixin':: d.fn(help='"The Amazon Resource Name (ARN) of the license configuration"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='licenseSpecifications', type=d.T.array)]),
      withLicenseSpecificationsMixin(licenseSpecifications): { spec+: { forProvider+: { licenseSpecifications+: if std.isArray(v=licenseSpecifications) then licenseSpecifications else [licenseSpecifications] } } },
      '#withNetworkInterfaces':: d.fn(help='"The network interfaces to associate with the instance. If you specify a network interface, you must specify any security groups and subnets as part of the network interface."', args=[d.arg(name='networkInterfaces', type=d.T.array)]),
      withNetworkInterfaces(networkInterfaces): { spec+: { forProvider+: { networkInterfaces: if std.isArray(v=networkInterfaces) then networkInterfaces else [networkInterfaces] } } },
      '#withNetworkInterfacesMixin':: d.fn(help='"The network interfaces to associate with the instance. If you specify a network interface, you must specify any security groups and subnets as part of the network interface."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkInterfaces', type=d.T.array)]),
      withNetworkInterfacesMixin(networkInterfaces): { spec+: { forProvider+: { networkInterfaces+: if std.isArray(v=networkInterfaces) then networkInterfaces else [networkInterfaces] } } },
      '#withPrivateIpAddress':: d.fn(help="\"[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. \\n Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request. \\n You cannot specify this option and the network interfaces option in the same request.\"", args=[d.arg(name='privateIpAddress', type=d.T.string)]),
      withPrivateIpAddress(privateIpAddress): { spec+: { forProvider+: { privateIpAddress: privateIpAddress } } },
      '#withRamDiskId':: d.fn(help='"The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID. \\n AWS recommends that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the Amazon Elastic Compute Cloud User Guide."', args=[d.arg(name='ramDiskId', type=d.T.string)]),
      withRamDiskId(ramDiskId): { spec+: { forProvider+: { ramDiskId: ramDiskId } } },
      '#withRegion':: d.fn(help="\"Region is the region you'd like your Instance to be created in.\"", args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { spec+: { forProvider+: { region: region } } },
      '#withSecurityGroupIds':: d.fn(help='"The IDs of the security groups. You can create a security group using CreateSecurityGroup (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html). \\n If you specify a network interface, you must specify any security groups as part of the network interface."', args=[d.arg(name='securityGroupIds', type=d.T.array)]),
      withSecurityGroupIds(securityGroupIds): { spec+: { forProvider+: { securityGroupIds: if std.isArray(v=securityGroupIds) then securityGroupIds else [securityGroupIds] } } },
      '#withSecurityGroupIdsMixin':: d.fn(help='"The IDs of the security groups. You can create a security group using CreateSecurityGroup (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html). \\n If you specify a network interface, you must specify any security groups as part of the network interface."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='securityGroupIds', type=d.T.array)]),
      withSecurityGroupIdsMixin(securityGroupIds): { spec+: { forProvider+: { securityGroupIds+: if std.isArray(v=securityGroupIds) then securityGroupIds else [securityGroupIds] } } },
      '#withSecurityGroupRefs':: d.fn(help='"SecurityGroupsRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs."', args=[d.arg(name='securityGroupRefs', type=d.T.array)]),
      withSecurityGroupRefs(securityGroupRefs): { spec+: { forProvider+: { securityGroupRefs: if std.isArray(v=securityGroupRefs) then securityGroupRefs else [securityGroupRefs] } } },
      '#withSecurityGroupRefsMixin':: d.fn(help='"SecurityGroupsRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='securityGroupRefs', type=d.T.array)]),
      withSecurityGroupRefsMixin(securityGroupRefs): { spec+: { forProvider+: { securityGroupRefs+: if std.isArray(v=securityGroupRefs) then securityGroupRefs else [securityGroupRefs] } } },
      '#withSubnetId':: d.fn(help='"[EC2-VPC] The ID of the subnet to launch the instance into. \\n If you specify a network interface, you must specify any subnets as part of the network interface."', args=[d.arg(name='subnetId', type=d.T.string)]),
      withSubnetId(subnetId): { spec+: { forProvider+: { subnetId: subnetId } } },
      '#withTagSpecifications':: d.fn(help='"The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html)."', args=[d.arg(name='tagSpecifications', type=d.T.array)]),
      withTagSpecifications(tagSpecifications): { spec+: { forProvider+: { tagSpecifications: if std.isArray(v=tagSpecifications) then tagSpecifications else [tagSpecifications] } } },
      '#withTagSpecificationsMixin':: d.fn(help='"The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tagSpecifications', type=d.T.array)]),
      withTagSpecificationsMixin(tagSpecifications): { spec+: { forProvider+: { tagSpecifications+: if std.isArray(v=tagSpecifications) then tagSpecifications else [tagSpecifications] } } },
      '#withTags':: d.fn(help='"Tags are used as identification helpers between AWS resources."', args=[d.arg(name='tags', type=d.T.array)]),
      withTags(tags): { spec+: { forProvider+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
      '#withTagsMixin':: d.fn(help='"Tags are used as identification helpers between AWS resources."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
      withTagsMixin(tags): { spec+: { forProvider+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
      '#withUserData':: d.fn(help='"The user data to make available to the instance. For more information, see Running Commands on Your Linux Instance at Launch (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) (Linux) and Adding User Data (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data) (Windows). If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text. User data is limited to 16 KB."', args=[d.arg(name='userData', type=d.T.string)]),
      withUserData(userData): { spec+: { forProvider+: { userData: userData } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured."'),
    providerConfigRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerConfigRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerConfigRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#providerRef':: d.obj(help='"ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`"'),
    providerRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerRef+: { name: name } } },
    },
    '#publishConnectionDetailsTo':: d.obj(help='"PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource."'),
    publishConnectionDetailsTo: {
      '#configRef':: d.obj(help='"SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret."'),
      configRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { publishConnectionDetailsTo+: { configRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { publishConnectionDetailsTo+: { configRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { publishConnectionDetailsTo+: { configRef+: { name: name } } } },
      },
      '#metadata':: d.obj(help='"Metadata is the metadata for connection secret."'),
      metadata: {
        '#withAnnotations':: d.fn(help='"Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.annotations\\". - It is up to Secret Store implementation for others store types."', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { spec+: { publishConnectionDetailsTo+: { metadata+: { annotations: annotations } } } },
        '#withAnnotationsMixin':: d.fn(help='"Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.annotations\\". - It is up to Secret Store implementation for others store types."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { spec+: { publishConnectionDetailsTo+: { metadata+: { annotations+: annotations } } } },
        '#withLabels':: d.fn(help='"Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.labels\\". - It is up to Secret Store implementation for others store types."', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { spec+: { publishConnectionDetailsTo+: { metadata+: { labels: labels } } } },
        '#withLabelsMixin':: d.fn(help='"Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.labels\\". - It is up to Secret Store implementation for others store types."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { spec+: { publishConnectionDetailsTo+: { metadata+: { labels+: labels } } } },
        '#withType':: d.fn(help='"Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores."', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { publishConnectionDetailsTo+: { metadata+: { type: type } } } },
      },
      '#withName':: d.fn(help='"Name is the name of the connection secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { publishConnectionDetailsTo+: { name: name } } },
    },
    '#withDeletionPolicy':: d.fn(help='"DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either \\"Delete\\" or \\"Orphan\\" the external resource."', args=[d.arg(name='deletionPolicy', type=d.T.string)]),
    withDeletionPolicy(deletionPolicy): { spec+: { deletionPolicy: deletionPolicy } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { writeConnectionSecretToRef+: { namespace: namespace } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}

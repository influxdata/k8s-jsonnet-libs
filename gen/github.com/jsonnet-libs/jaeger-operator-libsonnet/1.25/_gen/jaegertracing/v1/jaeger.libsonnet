{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='jaeger', url='', help=''),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Jaeger', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'jaegertracing.io/v1',
    kind: 'Jaeger',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help=''),
  spec: {
    '#affinity':: d.obj(help=''),
    affinity: {
      '#nodeAffinity':: d.obj(help=''),
      nodeAffinity: {
        '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
        preferredDuringSchedulingIgnoredDuringExecution: {
          '#preference':: d.obj(help=''),
          preference: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#matchFields':: d.obj(help=''),
            matchFields: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
            withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
            withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
          },
          '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
          withWeight(weight): { weight: weight },
        },
        '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
        requiredDuringSchedulingIgnoredDuringExecution: {
          '#nodeSelectorTerms':: d.obj(help=''),
          nodeSelectorTerms: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#matchFields':: d.obj(help=''),
            matchFields: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
            '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
            withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
            withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
          },
          '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
          withNodeSelectorTerms(nodeSelectorTerms): { spec+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } },
          '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
          withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } },
        },
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
      },
      '#podAffinity':: d.obj(help=''),
      podAffinity: {
        '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
        preferredDuringSchedulingIgnoredDuringExecution: {
          '#podAffinityTerm':: d.obj(help=''),
          podAffinityTerm: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
          },
          '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
          withWeight(weight): { weight: weight },
        },
        '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
        requiredDuringSchedulingIgnoredDuringExecution: {
          '#labelSelector':: d.obj(help=''),
          labelSelector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
          },
          '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
          withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
          '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
          withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
          '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
          withTopologyKey(topologyKey): { topologyKey: topologyKey },
        },
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
      },
      '#podAntiAffinity':: d.obj(help=''),
      podAntiAffinity: {
        '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
        preferredDuringSchedulingIgnoredDuringExecution: {
          '#podAffinityTerm':: d.obj(help=''),
          podAffinityTerm: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
          },
          '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
          withWeight(weight): { weight: weight },
        },
        '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
        requiredDuringSchedulingIgnoredDuringExecution: {
          '#labelSelector':: d.obj(help=''),
          labelSelector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
          },
          '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
          withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
          '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
          withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
          '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
          withTopologyKey(topologyKey): { topologyKey: topologyKey },
        },
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
      },
    },
    '#agent':: d.obj(help=''),
    agent: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { agent+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { agent+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { agent+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#imagePullSecrets':: d.obj(help=''),
      imagePullSecrets: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { agent+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { agent+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { agent+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { agent+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { agent+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { agent+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { agent+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { agent+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { agent+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { agent+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { agent+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { agent+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { agent+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { agent+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { agent+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { agent+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { agent+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { agent+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { agent+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { agent+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { agent+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { agent+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#sidecarSecurityContext':: d.obj(help=''),
      sidecarSecurityContext: {
        '#capabilities':: d.obj(help=''),
        capabilities: {
          '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
          withAdd(add): { spec+: { agent+: { sidecarSecurityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } } },
          '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
          withAddMixin(add): { spec+: { agent+: { sidecarSecurityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } } },
          '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
          withDrop(drop): { spec+: { agent+: { sidecarSecurityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } } },
          '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
          withDropMixin(drop): { spec+: { agent+: { sidecarSecurityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { agent+: { sidecarSecurityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { agent+: { sidecarSecurityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { agent+: { sidecarSecurityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { agent+: { sidecarSecurityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { agent+: { sidecarSecurityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { agent+: { sidecarSecurityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { agent+: { sidecarSecurityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { agent+: { sidecarSecurityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { agent+: { sidecarSecurityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
        withAllowPrivilegeEscalation(allowPrivilegeEscalation): { spec+: { agent+: { sidecarSecurityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } } },
        '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
        withPrivileged(privileged): { spec+: { agent+: { sidecarSecurityContext+: { privileged: privileged } } } },
        '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
        withProcMount(procMount): { spec+: { agent+: { sidecarSecurityContext+: { procMount: procMount } } } },
        '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
        withReadOnlyRootFilesystem(readOnlyRootFilesystem): { spec+: { agent+: { sidecarSecurityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { agent+: { sidecarSecurityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { agent+: { sidecarSecurityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { agent+: { sidecarSecurityContext+: { runAsUser: runAsUser } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
            '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
            '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
          },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { agent+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { agent+: { annotations+: annotations } } },
      '#withConfig':: d.fn(help='', args=[d.arg(name='config', type=d.T.object)]),
      withConfig(config): { spec+: { agent+: { config: config } } },
      '#withConfigMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
      withConfigMixin(config): { spec+: { agent+: { config+: config } } },
      '#withDnsPolicy':: d.fn(help='', args=[d.arg(name='dnsPolicy', type=d.T.string)]),
      withDnsPolicy(dnsPolicy): { spec+: { agent+: { dnsPolicy: dnsPolicy } } },
      '#withHostNetwork':: d.fn(help='', args=[d.arg(name='hostNetwork', type=d.T.boolean)]),
      withHostNetwork(hostNetwork): { spec+: { agent+: { hostNetwork: hostNetwork } } },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { agent+: { image: image } } },
      '#withImagePullSecrets':: d.fn(help='', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
      withImagePullSecrets(imagePullSecrets): { spec+: { agent+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } } },
      '#withImagePullSecretsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
      withImagePullSecretsMixin(imagePullSecrets): { spec+: { agent+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { agent+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { agent+: { labels+: labels } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { agent+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { agent+: { options+: options } } },
      '#withPriorityClassName':: d.fn(help='', args=[d.arg(name='priorityClassName', type=d.T.string)]),
      withPriorityClassName(priorityClassName): { spec+: { agent+: { priorityClassName: priorityClassName } } },
      '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
      withServiceAccount(serviceAccount): { spec+: { agent+: { serviceAccount: serviceAccount } } },
      '#withStrategy':: d.fn(help='', args=[d.arg(name='strategy', type=d.T.string)]),
      withStrategy(strategy): { spec+: { agent+: { strategy: strategy } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { agent+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { agent+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { agent+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { agent+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { agent+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { agent+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#allInOne':: d.obj(help=''),
    allInOne: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { allInOne+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { allInOne+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { allInOne+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { allInOne+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { allInOne+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { allInOne+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { allInOne+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { allInOne+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { allInOne+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { allInOne+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { allInOne+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { allInOne+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { allInOne+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { allInOne+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { allInOne+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { allInOne+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { allInOne+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { allInOne+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { allInOne+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { allInOne+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { allInOne+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { allInOne+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { allInOne+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { allInOne+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { allInOne+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#strategy':: d.obj(help=''),
      strategy: {
        '#rollingUpdate':: d.obj(help=''),
        rollingUpdate: {
          '#withMaxSurge':: d.fn(help='', args=[d.arg(name='maxSurge', type=d.T.any)]),
          withMaxSurge(maxSurge): { spec+: { allInOne+: { strategy+: { rollingUpdate+: { maxSurge: maxSurge } } } } },
          '#withMaxUnavailable':: d.fn(help='', args=[d.arg(name='maxUnavailable', type=d.T.any)]),
          withMaxUnavailable(maxUnavailable): { spec+: { allInOne+: { strategy+: { rollingUpdate+: { maxUnavailable: maxUnavailable } } } } },
        },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { allInOne+: { strategy+: { type: type } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
            '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
            '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
          },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { allInOne+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { allInOne+: { annotations+: annotations } } },
      '#withConfig':: d.fn(help='', args=[d.arg(name='config', type=d.T.object)]),
      withConfig(config): { spec+: { allInOne+: { config: config } } },
      '#withConfigMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
      withConfigMixin(config): { spec+: { allInOne+: { config+: config } } },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { allInOne+: { image: image } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { allInOne+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { allInOne+: { labels+: labels } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { allInOne+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { allInOne+: { options+: options } } },
      '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
      withServiceAccount(serviceAccount): { spec+: { allInOne+: { serviceAccount: serviceAccount } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { allInOne+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { allInOne+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTracingEnabled':: d.fn(help='', args=[d.arg(name='tracingEnabled', type=d.T.boolean)]),
      withTracingEnabled(tracingEnabled): { spec+: { allInOne+: { tracingEnabled: tracingEnabled } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { allInOne+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { allInOne+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { allInOne+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { allInOne+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#collector':: d.obj(help=''),
    collector: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { collector+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { collector+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { collector+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { collector+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { collector+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { collector+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { collector+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { collector+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { collector+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { collector+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { collector+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { collector+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { collector+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { collector+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { collector+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { collector+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { collector+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { collector+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { collector+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { collector+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { collector+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { collector+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { collector+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { collector+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { collector+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#strategy':: d.obj(help=''),
      strategy: {
        '#rollingUpdate':: d.obj(help=''),
        rollingUpdate: {
          '#withMaxSurge':: d.fn(help='', args=[d.arg(name='maxSurge', type=d.T.any)]),
          withMaxSurge(maxSurge): { spec+: { collector+: { strategy+: { rollingUpdate+: { maxSurge: maxSurge } } } } },
          '#withMaxUnavailable':: d.fn(help='', args=[d.arg(name='maxUnavailable', type=d.T.any)]),
          withMaxUnavailable(maxUnavailable): { spec+: { collector+: { strategy+: { rollingUpdate+: { maxUnavailable: maxUnavailable } } } } },
        },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { collector+: { strategy+: { type: type } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
            '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
            '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
          },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { collector+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { collector+: { annotations+: annotations } } },
      '#withAutoscale':: d.fn(help='', args=[d.arg(name='autoscale', type=d.T.boolean)]),
      withAutoscale(autoscale): { spec+: { collector+: { autoscale: autoscale } } },
      '#withConfig':: d.fn(help='', args=[d.arg(name='config', type=d.T.object)]),
      withConfig(config): { spec+: { collector+: { config: config } } },
      '#withConfigMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
      withConfigMixin(config): { spec+: { collector+: { config+: config } } },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { collector+: { image: image } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { collector+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { collector+: { labels+: labels } } },
      '#withMaxReplicas':: d.fn(help='', args=[d.arg(name='maxReplicas', type=d.T.integer)]),
      withMaxReplicas(maxReplicas): { spec+: { collector+: { maxReplicas: maxReplicas } } },
      '#withMinReplicas':: d.fn(help='', args=[d.arg(name='minReplicas', type=d.T.integer)]),
      withMinReplicas(minReplicas): { spec+: { collector+: { minReplicas: minReplicas } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { collector+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { collector+: { options+: options } } },
      '#withPriorityClassName':: d.fn(help='', args=[d.arg(name='priorityClassName', type=d.T.string)]),
      withPriorityClassName(priorityClassName): { spec+: { collector+: { priorityClassName: priorityClassName } } },
      '#withReplicas':: d.fn(help='', args=[d.arg(name='replicas', type=d.T.integer)]),
      withReplicas(replicas): { spec+: { collector+: { replicas: replicas } } },
      '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
      withServiceAccount(serviceAccount): { spec+: { collector+: { serviceAccount: serviceAccount } } },
      '#withServiceType':: d.fn(help='', args=[d.arg(name='serviceType', type=d.T.string)]),
      withServiceType(serviceType): { spec+: { collector+: { serviceType: serviceType } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { collector+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { collector+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { collector+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { collector+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { collector+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { collector+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#ingester':: d.obj(help=''),
    ingester: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { ingester+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { ingester+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingester+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { ingester+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { ingester+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { ingester+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { ingester+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { ingester+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { ingester+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { ingester+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { ingester+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { ingester+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { ingester+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { ingester+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { ingester+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { ingester+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { ingester+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { ingester+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { ingester+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { ingester+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { ingester+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { ingester+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { ingester+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { ingester+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { ingester+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#strategy':: d.obj(help=''),
      strategy: {
        '#rollingUpdate':: d.obj(help=''),
        rollingUpdate: {
          '#withMaxSurge':: d.fn(help='', args=[d.arg(name='maxSurge', type=d.T.any)]),
          withMaxSurge(maxSurge): { spec+: { ingester+: { strategy+: { rollingUpdate+: { maxSurge: maxSurge } } } } },
          '#withMaxUnavailable':: d.fn(help='', args=[d.arg(name='maxUnavailable', type=d.T.any)]),
          withMaxUnavailable(maxUnavailable): { spec+: { ingester+: { strategy+: { rollingUpdate+: { maxUnavailable: maxUnavailable } } } } },
        },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { ingester+: { strategy+: { type: type } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
            '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
            '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
          },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { ingester+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { ingester+: { annotations+: annotations } } },
      '#withAutoscale':: d.fn(help='', args=[d.arg(name='autoscale', type=d.T.boolean)]),
      withAutoscale(autoscale): { spec+: { ingester+: { autoscale: autoscale } } },
      '#withConfig':: d.fn(help='', args=[d.arg(name='config', type=d.T.object)]),
      withConfig(config): { spec+: { ingester+: { config: config } } },
      '#withConfigMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
      withConfigMixin(config): { spec+: { ingester+: { config+: config } } },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { ingester+: { image: image } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { ingester+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { ingester+: { labels+: labels } } },
      '#withMaxReplicas':: d.fn(help='', args=[d.arg(name='maxReplicas', type=d.T.integer)]),
      withMaxReplicas(maxReplicas): { spec+: { ingester+: { maxReplicas: maxReplicas } } },
      '#withMinReplicas':: d.fn(help='', args=[d.arg(name='minReplicas', type=d.T.integer)]),
      withMinReplicas(minReplicas): { spec+: { ingester+: { minReplicas: minReplicas } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { ingester+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { ingester+: { options+: options } } },
      '#withReplicas':: d.fn(help='', args=[d.arg(name='replicas', type=d.T.integer)]),
      withReplicas(replicas): { spec+: { ingester+: { replicas: replicas } } },
      '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
      withServiceAccount(serviceAccount): { spec+: { ingester+: { serviceAccount: serviceAccount } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { ingester+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { ingester+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { ingester+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { ingester+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { ingester+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { ingester+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#ingress':: d.obj(help=''),
    ingress: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { ingress+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { ingress+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { ingress+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#openshift':: d.obj(help=''),
      openshift: {
        '#withDelegateUrls':: d.fn(help='', args=[d.arg(name='delegateUrls', type=d.T.string)]),
        withDelegateUrls(delegateUrls): { spec+: { ingress+: { openshift+: { delegateUrls: delegateUrls } } } },
        '#withHtpasswdFile':: d.fn(help='', args=[d.arg(name='htpasswdFile', type=d.T.string)]),
        withHtpasswdFile(htpasswdFile): { spec+: { ingress+: { openshift+: { htpasswdFile: htpasswdFile } } } },
        '#withSar':: d.fn(help='', args=[d.arg(name='sar', type=d.T.string)]),
        withSar(sar): { spec+: { ingress+: { openshift+: { sar: sar } } } },
        '#withSkipLogout':: d.fn(help='', args=[d.arg(name='skipLogout', type=d.T.boolean)]),
        withSkipLogout(skipLogout): { spec+: { ingress+: { openshift+: { skipLogout: skipLogout } } } },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { ingress+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { ingress+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { ingress+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { ingress+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { ingress+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { ingress+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { ingress+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { ingress+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { ingress+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { ingress+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { ingress+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { ingress+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { ingress+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { ingress+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { ingress+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { ingress+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { ingress+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { ingress+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { ingress+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { ingress+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { ingress+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { ingress+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#tls':: d.obj(help=''),
      tls: {
        '#withHosts':: d.fn(help='', args=[d.arg(name='hosts', type=d.T.array)]),
        withHosts(hosts): { hosts: if std.isArray(v=hosts) then hosts else [hosts] },
        '#withHostsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hosts', type=d.T.array)]),
        withHostsMixin(hosts): { hosts+: if std.isArray(v=hosts) then hosts else [hosts] },
        '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
        withSecretName(secretName): { secretName: secretName },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
            '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
            '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
          },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { ingress+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { ingress+: { annotations+: annotations } } },
      '#withEnabled':: d.fn(help='', args=[d.arg(name='enabled', type=d.T.boolean)]),
      withEnabled(enabled): { spec+: { ingress+: { enabled: enabled } } },
      '#withHosts':: d.fn(help='', args=[d.arg(name='hosts', type=d.T.array)]),
      withHosts(hosts): { spec+: { ingress+: { hosts: if std.isArray(v=hosts) then hosts else [hosts] } } },
      '#withHostsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hosts', type=d.T.array)]),
      withHostsMixin(hosts): { spec+: { ingress+: { hosts+: if std.isArray(v=hosts) then hosts else [hosts] } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { ingress+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { ingress+: { labels+: labels } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { ingress+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { ingress+: { options+: options } } },
      '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
      withSecretName(secretName): { spec+: { ingress+: { secretName: secretName } } },
      '#withSecurity':: d.fn(help='', args=[d.arg(name='security', type=d.T.string)]),
      withSecurity(security): { spec+: { ingress+: { security: security } } },
      '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
      withServiceAccount(serviceAccount): { spec+: { ingress+: { serviceAccount: serviceAccount } } },
      '#withTls':: d.fn(help='', args=[d.arg(name='tls', type=d.T.array)]),
      withTls(tls): { spec+: { ingress+: { tls: if std.isArray(v=tls) then tls else [tls] } } },
      '#withTlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tls', type=d.T.array)]),
      withTlsMixin(tls): { spec+: { ingress+: { tls+: if std.isArray(v=tls) then tls else [tls] } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { ingress+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { ingress+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { ingress+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { ingress+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { ingress+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { ingress+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#query':: d.obj(help=''),
    query: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { query+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { query+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { query+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { query+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { query+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { query+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { query+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { query+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { query+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { query+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { query+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { query+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { query+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { query+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { query+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { query+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { query+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { query+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { query+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { query+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { query+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { query+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { query+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { query+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { query+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#strategy':: d.obj(help=''),
      strategy: {
        '#rollingUpdate':: d.obj(help=''),
        rollingUpdate: {
          '#withMaxSurge':: d.fn(help='', args=[d.arg(name='maxSurge', type=d.T.any)]),
          withMaxSurge(maxSurge): { spec+: { query+: { strategy+: { rollingUpdate+: { maxSurge: maxSurge } } } } },
          '#withMaxUnavailable':: d.fn(help='', args=[d.arg(name='maxUnavailable', type=d.T.any)]),
          withMaxUnavailable(maxUnavailable): { spec+: { query+: { strategy+: { rollingUpdate+: { maxUnavailable: maxUnavailable } } } } },
        },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { query+: { strategy+: { type: type } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
            '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
            '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
            withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
          },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { query+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { query+: { annotations+: annotations } } },
      '#withGrpcNodePort':: d.fn(help='', args=[d.arg(name='grpcNodePort', type=d.T.integer)]),
      withGrpcNodePort(grpcNodePort): { spec+: { query+: { grpcNodePort: grpcNodePort } } },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { query+: { image: image } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { query+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { query+: { labels+: labels } } },
      '#withNodePort':: d.fn(help='', args=[d.arg(name='nodePort', type=d.T.integer)]),
      withNodePort(nodePort): { spec+: { query+: { nodePort: nodePort } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { query+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { query+: { options+: options } } },
      '#withPriorityClassName':: d.fn(help='', args=[d.arg(name='priorityClassName', type=d.T.string)]),
      withPriorityClassName(priorityClassName): { spec+: { query+: { priorityClassName: priorityClassName } } },
      '#withReplicas':: d.fn(help='', args=[d.arg(name='replicas', type=d.T.integer)]),
      withReplicas(replicas): { spec+: { query+: { replicas: replicas } } },
      '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
      withServiceAccount(serviceAccount): { spec+: { query+: { serviceAccount: serviceAccount } } },
      '#withServiceType':: d.fn(help='', args=[d.arg(name='serviceType', type=d.T.string)]),
      withServiceType(serviceType): { spec+: { query+: { serviceType: serviceType } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { query+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { query+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTracingEnabled':: d.fn(help='', args=[d.arg(name='tracingEnabled', type=d.T.boolean)]),
      withTracingEnabled(tracingEnabled): { spec+: { query+: { tracingEnabled: tracingEnabled } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { query+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { query+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { query+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { query+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#resources':: d.obj(help=''),
    resources: {
      '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
      withLimits(limits): { spec+: { resources+: { limits: limits } } },
      '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
      withLimitsMixin(limits): { spec+: { resources+: { limits+: limits } } },
      '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
      withRequests(requests): { spec+: { resources+: { requests: requests } } },
      '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
      withRequestsMixin(requests): { spec+: { resources+: { requests+: requests } } },
    },
    '#sampling':: d.obj(help=''),
    sampling: {
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { sampling+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { sampling+: { options+: options } } },
    },
    '#securityContext':: d.obj(help=''),
    securityContext: {
      '#seLinuxOptions':: d.obj(help=''),
      seLinuxOptions: {
        '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
        withLevel(level): { spec+: { securityContext+: { seLinuxOptions+: { level: level } } } },
        '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
        withRole(role): { spec+: { securityContext+: { seLinuxOptions+: { role: role } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { securityContext+: { seLinuxOptions+: { type: type } } } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { spec+: { securityContext+: { seLinuxOptions+: { user: user } } } },
      },
      '#seccompProfile':: d.obj(help=''),
      seccompProfile: {
        '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
        withLocalhostProfile(localhostProfile): { spec+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { securityContext+: { seccompProfile+: { type: type } } } },
      },
      '#sysctls':: d.obj(help=''),
      sysctls: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#windowsOptions':: d.obj(help=''),
      windowsOptions: {
        '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
        withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
        '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
        withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
        '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
        withRunAsUserName(runAsUserName): { spec+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
      },
      '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
      withFsGroup(fsGroup): { spec+: { securityContext+: { fsGroup: fsGroup } } },
      '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
      withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } },
      '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
      withRunAsGroup(runAsGroup): { spec+: { securityContext+: { runAsGroup: runAsGroup } } },
      '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
      withRunAsNonRoot(runAsNonRoot): { spec+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
      '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
      withRunAsUser(runAsUser): { spec+: { securityContext+: { runAsUser: runAsUser } } },
      '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
      withSupplementalGroups(supplementalGroups): { spec+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } },
      '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
      withSupplementalGroupsMixin(supplementalGroups): { spec+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } },
      '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
      withSysctls(sysctls): { spec+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } },
      '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
      withSysctlsMixin(sysctls): { spec+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } },
    },
    '#storage':: d.obj(help=''),
    storage: {
      '#cassandraCreateSchema':: d.obj(help=''),
      cassandraCreateSchema: {
        '#affinity':: d.obj(help=''),
        affinity: {
          '#nodeAffinity':: d.obj(help=''),
          nodeAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#preference':: d.obj(help=''),
              preference: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#nodeSelectorTerms':: d.obj(help=''),
              nodeSelectorTerms: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              },
              '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTerms(nodeSelectorTerms): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
              '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAffinity':: d.obj(help=''),
          podAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAntiAffinity':: d.obj(help=''),
          podAntiAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { cassandraCreateSchema+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
        },
        '#withDatacenter':: d.fn(help='', args=[d.arg(name='datacenter', type=d.T.string)]),
        withDatacenter(datacenter): { spec+: { storage+: { cassandraCreateSchema+: { datacenter: datacenter } } } },
        '#withEnabled':: d.fn(help='', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { storage+: { cassandraCreateSchema+: { enabled: enabled } } } },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { spec+: { storage+: { cassandraCreateSchema+: { image: image } } } },
        '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.string)]),
        withMode(mode): { spec+: { storage+: { cassandraCreateSchema+: { mode: mode } } } },
        '#withTimeout':: d.fn(help='', args=[d.arg(name='timeout', type=d.T.string)]),
        withTimeout(timeout): { spec+: { storage+: { cassandraCreateSchema+: { timeout: timeout } } } },
        '#withTraceTTL':: d.fn(help='', args=[d.arg(name='traceTTL', type=d.T.string)]),
        withTraceTTL(traceTTL): { spec+: { storage+: { cassandraCreateSchema+: { traceTTL: traceTTL } } } },
        '#withTtlSecondsAfterFinished':: d.fn(help='', args=[d.arg(name='ttlSecondsAfterFinished', type=d.T.integer)]),
        withTtlSecondsAfterFinished(ttlSecondsAfterFinished): { spec+: { storage+: { cassandraCreateSchema+: { ttlSecondsAfterFinished: ttlSecondsAfterFinished } } } },
      },
      '#dependencies':: d.obj(help=''),
      dependencies: {
        '#affinity':: d.obj(help=''),
        affinity: {
          '#nodeAffinity':: d.obj(help=''),
          nodeAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#preference':: d.obj(help=''),
              preference: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#nodeSelectorTerms':: d.obj(help=''),
              nodeSelectorTerms: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              },
              '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTerms(nodeSelectorTerms): { spec+: { storage+: { dependencies+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
              '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { storage+: { dependencies+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAffinity':: d.obj(help=''),
          podAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAntiAffinity':: d.obj(help=''),
          podAntiAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { dependencies+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
        },
        '#resources':: d.obj(help=''),
        resources: {
          '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { spec+: { storage+: { dependencies+: { resources+: { limits: limits } } } } },
          '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { spec+: { storage+: { dependencies+: { resources+: { limits+: limits } } } } },
          '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { spec+: { storage+: { dependencies+: { resources+: { requests: requests } } } } },
          '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { spec+: { storage+: { dependencies+: { resources+: { requests+: requests } } } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { spec+: { storage+: { dependencies+: { securityContext+: { seLinuxOptions+: { level: level } } } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { spec+: { storage+: { dependencies+: { securityContext+: { seLinuxOptions+: { role: role } } } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { spec+: { storage+: { dependencies+: { securityContext+: { seLinuxOptions+: { type: type } } } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { spec+: { storage+: { dependencies+: { securityContext+: { seLinuxOptions+: { user: user } } } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { spec+: { storage+: { dependencies+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { spec+: { storage+: { dependencies+: { securityContext+: { seccompProfile+: { type: type } } } } } },
          },
          '#sysctls':: d.obj(help=''),
          sysctls: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { storage+: { dependencies+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { storage+: { dependencies+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { spec+: { storage+: { dependencies+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } } },
          },
          '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
          withFsGroup(fsGroup): { spec+: { storage+: { dependencies+: { securityContext+: { fsGroup: fsGroup } } } } },
          '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
          withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { storage+: { dependencies+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { spec+: { storage+: { dependencies+: { securityContext+: { runAsGroup: runAsGroup } } } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { spec+: { storage+: { dependencies+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { spec+: { storage+: { dependencies+: { securityContext+: { runAsUser: runAsUser } } } } },
          '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
          withSupplementalGroups(supplementalGroups): { spec+: { storage+: { dependencies+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } } },
          '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
          withSupplementalGroupsMixin(supplementalGroups): { spec+: { storage+: { dependencies+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } } },
          '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
          withSysctls(sysctls): { spec+: { storage+: { dependencies+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } } },
          '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
          withSysctlsMixin(sysctls): { spec+: { storage+: { dependencies+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } } },
        },
        '#tolerations':: d.obj(help=''),
        tolerations: {
          '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
          withEffect(effect): { effect: effect },
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
          withOperator(operator): { operator: operator },
          '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
          withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#volumes':: d.obj(help=''),
        volumes: {
          '#awsElasticBlockStore':: d.obj(help=''),
          awsElasticBlockStore: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
            '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
            withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
          },
          '#azureDisk':: d.obj(help=''),
          azureDisk: {
            '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
            withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
            '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
            withDiskName(diskName): { azureDisk+: { diskName: diskName } },
            '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
            withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { azureDisk+: { fsType: fsType } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { azureDisk+: { kind: kind } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
          },
          '#azureFile':: d.obj(help=''),
          azureFile: {
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
            '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { azureFile+: { secretName: secretName } },
            '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
            withShareName(shareName): { azureFile+: { shareName: shareName } },
          },
          '#cephfs':: d.obj(help=''),
          cephfs: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cephfs+: { secretRef+: { name: name } } },
            },
            '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { cephfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
            '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
            withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { cephfs+: { user: user } },
          },
          '#cinder':: d.obj(help=''),
          cinder: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cinder+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { cinder+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
          },
          '#configMap':: d.obj(help=''),
          configMap: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMap+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMap+: { optional: optional } },
          },
          '#csi':: d.obj(help=''),
          csi: {
            '#nodePublishSecretRef':: d.obj(help=''),
            nodePublishSecretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
            },
            '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
            withDriver(driver): { csi+: { driver: driver } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { csi+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
            '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
            withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
            '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
            withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
          },
          '#downwardAPI':: d.obj(help=''),
          downwardAPI: {
            '#items':: d.obj(help=''),
            items: {
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { resourceFieldRef+: { resource: resource } },
              },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
          },
          '#emptyDir':: d.obj(help=''),
          emptyDir: {
            '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
            withMedium(medium): { emptyDir+: { medium: medium } },
            '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
            withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
          },
          '#ephemeral':: d.obj(help=''),
          ephemeral: {
            '#volumeClaimTemplate':: d.obj(help=''),
            volumeClaimTemplate: {
              '#spec':: d.obj(help=''),
              spec: {
                '#dataSource':: d.obj(help=''),
                dataSource: {
                  '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                  withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                  '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                  withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                  '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
                },
                '#resources':: d.obj(help=''),
                resources: {
                  '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                  withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                  '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                  withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                  '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                  withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                  '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                  withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
                },
                '#selector':: d.obj(help=''),
                selector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
                },
                '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
                withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
                '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
                withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
                '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
                withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
                '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
                withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
                '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
                withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
              },
              '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
              '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
            },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
          },
          '#fc':: d.obj(help=''),
          fc: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { fc+: { fsType: fsType } },
            '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
            withLun(lun): { fc+: { lun: lun } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
            '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
            withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
            '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
            withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
            '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
            withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
            '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
            withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
          },
          '#flexVolume':: d.obj(help=''),
          flexVolume: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { flexVolume+: { secretRef+: { name: name } } },
            },
            '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
            withDriver(driver): { flexVolume+: { driver: driver } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { flexVolume+: { fsType: fsType } },
            '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
            withOptions(options): { flexVolume+: { options: options } },
            '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
            withOptionsMixin(options): { flexVolume+: { options+: options } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
          },
          '#flocker':: d.obj(help=''),
          flocker: {
            '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
            withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
            '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
            withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
          },
          '#gcePersistentDisk':: d.obj(help=''),
          gcePersistentDisk: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
            '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
            withPartition(partition): { gcePersistentDisk+: { partition: partition } },
            '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
            withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
          },
          '#gitRepo':: d.obj(help=''),
          gitRepo: {
            '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
            withDirectory(directory): { gitRepo+: { directory: directory } },
            '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
            withRepository(repository): { gitRepo+: { repository: repository } },
            '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
            withRevision(revision): { gitRepo+: { revision: revision } },
          },
          '#glusterfs':: d.obj(help=''),
          glusterfs: {
            '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
            withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { glusterfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
          },
          '#hostPath':: d.obj(help=''),
          hostPath: {
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { hostPath+: { path: path } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { hostPath+: { type: type } },
          },
          '#iscsi':: d.obj(help=''),
          iscsi: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { iscsi+: { secretRef+: { name: name } } },
            },
            '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
            withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
            '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
            withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { iscsi+: { fsType: fsType } },
            '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
            withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
            '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
            withIqn(iqn): { iscsi+: { iqn: iqn } },
            '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
            withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
            '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
            withLun(lun): { iscsi+: { lun: lun } },
            '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
            withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
            '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
            withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
            '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
            withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
          },
          '#nfs':: d.obj(help=''),
          nfs: {
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { nfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
            '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
            withServer(server): { nfs+: { server: server } },
          },
          '#persistentVolumeClaim':: d.obj(help=''),
          persistentVolumeClaim: {
            '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
            withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
          },
          '#photonPersistentDisk':: d.obj(help=''),
          photonPersistentDisk: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
            '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
            withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
          },
          '#portworxVolume':: d.obj(help=''),
          portworxVolume: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { portworxVolume+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
          },
          '#projected':: d.obj(help=''),
          projected: {
            '#sources':: d.obj(help=''),
            sources: {
              '#configMap':: d.obj(help=''),
              configMap: {
                '#items':: d.obj(help=''),
                items: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { configMap+: { name: name } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { configMap+: { optional: optional } },
              },
              '#downwardAPI':: d.obj(help=''),
              downwardAPI: {
                '#items':: d.obj(help=''),
                items: {
                  '#fieldRef':: d.obj(help=''),
                  fieldRef: {
                    '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                    withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                    '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                    withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                  },
                  '#resourceFieldRef':: d.obj(help=''),
                  resourceFieldRef: {
                    '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                    withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                    '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                    withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                    '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                    withResource(resource): { resourceFieldRef+: { resource: resource } },
                  },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
              },
              '#secret':: d.obj(help=''),
              secret: {
                '#items':: d.obj(help=''),
                items: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { secret+: { name: name } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { secret+: { optional: optional } },
              },
              '#serviceAccountToken':: d.obj(help=''),
              serviceAccountToken: {
                '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
                withAudience(audience): { serviceAccountToken+: { audience: audience } },
                '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
                withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { serviceAccountToken+: { path: path } },
              },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
            '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
            withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
            '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
            withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
          },
          '#quobyte':: d.obj(help=''),
          quobyte: {
            '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
            withGroup(group): { quobyte+: { group: group } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
            '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
            withRegistry(registry): { quobyte+: { registry: registry } },
            '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
            withTenant(tenant): { quobyte+: { tenant: tenant } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { quobyte+: { user: user } },
            '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
            withVolume(volume): { quobyte+: { volume: volume } },
          },
          '#rbd':: d.obj(help=''),
          rbd: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { rbd+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { rbd+: { fsType: fsType } },
            '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
            withImage(image): { rbd+: { image: image } },
            '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
            withKeyring(keyring): { rbd+: { keyring: keyring } },
            '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
            withPool(pool): { rbd+: { pool: pool } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { rbd+: { user: user } },
          },
          '#scaleIO':: d.obj(help=''),
          scaleIO: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { scaleIO+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { scaleIO+: { fsType: fsType } },
            '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
            withGateway(gateway): { scaleIO+: { gateway: gateway } },
            '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
            withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
            '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
            withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
            '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
            withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
            '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
            withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
            '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
            withSystem(system): { scaleIO+: { system: system } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
          },
          '#secret':: d.obj(help=''),
          secret: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secret+: { optional: optional } },
            '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { secret+: { secretName: secretName } },
          },
          '#storageos':: d.obj(help=''),
          storageos: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { storageos+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { storageos+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
            '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
            withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
          },
          '#vsphereVolume':: d.obj(help=''),
          vsphereVolume: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
            '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
            withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
            '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
            withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
            '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
            withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { spec+: { storage+: { dependencies+: { annotations: annotations } } } },
        '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { spec+: { storage+: { dependencies+: { annotations+: annotations } } } },
        '#withBackoffLimit':: d.fn(help='', args=[d.arg(name='backoffLimit', type=d.T.integer)]),
        withBackoffLimit(backoffLimit): { spec+: { storage+: { dependencies+: { backoffLimit: backoffLimit } } } },
        '#withCassandraClientAuthEnabled':: d.fn(help='', args=[d.arg(name='cassandraClientAuthEnabled', type=d.T.boolean)]),
        withCassandraClientAuthEnabled(cassandraClientAuthEnabled): { spec+: { storage+: { dependencies+: { cassandraClientAuthEnabled: cassandraClientAuthEnabled } } } },
        '#withElasticsearchClientNodeOnly':: d.fn(help='', args=[d.arg(name='elasticsearchClientNodeOnly', type=d.T.boolean)]),
        withElasticsearchClientNodeOnly(elasticsearchClientNodeOnly): { spec+: { storage+: { dependencies+: { elasticsearchClientNodeOnly: elasticsearchClientNodeOnly } } } },
        '#withElasticsearchNodesWanOnly':: d.fn(help='', args=[d.arg(name='elasticsearchNodesWanOnly', type=d.T.boolean)]),
        withElasticsearchNodesWanOnly(elasticsearchNodesWanOnly): { spec+: { storage+: { dependencies+: { elasticsearchNodesWanOnly: elasticsearchNodesWanOnly } } } },
        '#withElasticsearchTimeRange':: d.fn(help='', args=[d.arg(name='elasticsearchTimeRange', type=d.T.string)]),
        withElasticsearchTimeRange(elasticsearchTimeRange): { spec+: { storage+: { dependencies+: { elasticsearchTimeRange: elasticsearchTimeRange } } } },
        '#withEnabled':: d.fn(help='', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { storage+: { dependencies+: { enabled: enabled } } } },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { spec+: { storage+: { dependencies+: { image: image } } } },
        '#withJavaOpts':: d.fn(help='', args=[d.arg(name='javaOpts', type=d.T.string)]),
        withJavaOpts(javaOpts): { spec+: { storage+: { dependencies+: { javaOpts: javaOpts } } } },
        '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { spec+: { storage+: { dependencies+: { labels: labels } } } },
        '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { spec+: { storage+: { dependencies+: { labels+: labels } } } },
        '#withSchedule':: d.fn(help='', args=[d.arg(name='schedule', type=d.T.string)]),
        withSchedule(schedule): { spec+: { storage+: { dependencies+: { schedule: schedule } } } },
        '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
        withServiceAccount(serviceAccount): { spec+: { storage+: { dependencies+: { serviceAccount: serviceAccount } } } },
        '#withSparkMaster':: d.fn(help='', args=[d.arg(name='sparkMaster', type=d.T.string)]),
        withSparkMaster(sparkMaster): { spec+: { storage+: { dependencies+: { sparkMaster: sparkMaster } } } },
        '#withSuccessfulJobsHistoryLimit':: d.fn(help='', args=[d.arg(name='successfulJobsHistoryLimit', type=d.T.integer)]),
        withSuccessfulJobsHistoryLimit(successfulJobsHistoryLimit): { spec+: { storage+: { dependencies+: { successfulJobsHistoryLimit: successfulJobsHistoryLimit } } } },
        '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerations(tolerations): { spec+: { storage+: { dependencies+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerationsMixin(tolerations): { spec+: { storage+: { dependencies+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTtlSecondsAfterFinished':: d.fn(help='', args=[d.arg(name='ttlSecondsAfterFinished', type=d.T.integer)]),
        withTtlSecondsAfterFinished(ttlSecondsAfterFinished): { spec+: { storage+: { dependencies+: { ttlSecondsAfterFinished: ttlSecondsAfterFinished } } } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { spec+: { storage+: { dependencies+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { spec+: { storage+: { dependencies+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } } },
        '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
        withVolumes(volumes): { spec+: { storage+: { dependencies+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } } },
        '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
        withVolumesMixin(volumes): { spec+: { storage+: { dependencies+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } } },
      },
      '#elasticsearch':: d.obj(help=''),
      elasticsearch: {
        '#resources':: d.obj(help=''),
        resources: {
          '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { spec+: { storage+: { elasticsearch+: { resources+: { limits: limits } } } } },
          '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { spec+: { storage+: { elasticsearch+: { resources+: { limits+: limits } } } } },
          '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { spec+: { storage+: { elasticsearch+: { resources+: { requests: requests } } } } },
          '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { spec+: { storage+: { elasticsearch+: { resources+: { requests+: requests } } } } },
        },
        '#storage':: d.obj(help=''),
        storage: {
          '#withSize':: d.fn(help='', args=[d.arg(name='size', type=d.T.any)]),
          withSize(size): { spec+: { storage+: { elasticsearch+: { storage+: { size: size } } } } },
          '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
          withStorageClassName(storageClassName): { spec+: { storage+: { elasticsearch+: { storage+: { storageClassName: storageClassName } } } } },
        },
        '#tolerations':: d.obj(help=''),
        tolerations: {
          '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
          withEffect(effect): { effect: effect },
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
          withOperator(operator): { operator: operator },
          '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
          withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { spec+: { storage+: { elasticsearch+: { image: image } } } },
        '#withNodeCount':: d.fn(help='', args=[d.arg(name='nodeCount', type=d.T.integer)]),
        withNodeCount(nodeCount): { spec+: { storage+: { elasticsearch+: { nodeCount: nodeCount } } } },
        '#withNodeSelector':: d.fn(help='', args=[d.arg(name='nodeSelector', type=d.T.object)]),
        withNodeSelector(nodeSelector): { spec+: { storage+: { elasticsearch+: { nodeSelector: nodeSelector } } } },
        '#withNodeSelectorMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelector', type=d.T.object)]),
        withNodeSelectorMixin(nodeSelector): { spec+: { storage+: { elasticsearch+: { nodeSelector+: nodeSelector } } } },
        '#withRedundancyPolicy':: d.fn(help='', args=[d.arg(name='redundancyPolicy', type=d.T.string)]),
        withRedundancyPolicy(redundancyPolicy): { spec+: { storage+: { elasticsearch+: { redundancyPolicy: redundancyPolicy } } } },
        '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerations(tolerations): { spec+: { storage+: { elasticsearch+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerationsMixin(tolerations): { spec+: { storage+: { elasticsearch+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
      },
      '#esIndexCleaner':: d.obj(help=''),
      esIndexCleaner: {
        '#affinity':: d.obj(help=''),
        affinity: {
          '#nodeAffinity':: d.obj(help=''),
          nodeAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#preference':: d.obj(help=''),
              preference: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#nodeSelectorTerms':: d.obj(help=''),
              nodeSelectorTerms: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              },
              '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTerms(nodeSelectorTerms): { spec+: { storage+: { esIndexCleaner+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
              '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { storage+: { esIndexCleaner+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAffinity':: d.obj(help=''),
          podAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAntiAffinity':: d.obj(help=''),
          podAntiAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esIndexCleaner+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
        },
        '#resources':: d.obj(help=''),
        resources: {
          '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { spec+: { storage+: { esIndexCleaner+: { resources+: { limits: limits } } } } },
          '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { spec+: { storage+: { esIndexCleaner+: { resources+: { limits+: limits } } } } },
          '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { spec+: { storage+: { esIndexCleaner+: { resources+: { requests: requests } } } } },
          '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { spec+: { storage+: { esIndexCleaner+: { resources+: { requests+: requests } } } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { seLinuxOptions+: { level: level } } } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { seLinuxOptions+: { role: role } } } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { seLinuxOptions+: { type: type } } } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { seLinuxOptions+: { user: user } } } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { seccompProfile+: { type: type } } } } } },
          },
          '#sysctls':: d.obj(help=''),
          sysctls: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } } },
          },
          '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
          withFsGroup(fsGroup): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { fsGroup: fsGroup } } } } },
          '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
          withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { runAsGroup: runAsGroup } } } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { runAsUser: runAsUser } } } } },
          '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
          withSupplementalGroups(supplementalGroups): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } } },
          '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
          withSupplementalGroupsMixin(supplementalGroups): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } } },
          '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
          withSysctls(sysctls): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } } },
          '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
          withSysctlsMixin(sysctls): { spec+: { storage+: { esIndexCleaner+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } } },
        },
        '#tolerations':: d.obj(help=''),
        tolerations: {
          '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
          withEffect(effect): { effect: effect },
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
          withOperator(operator): { operator: operator },
          '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
          withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#volumes':: d.obj(help=''),
        volumes: {
          '#awsElasticBlockStore':: d.obj(help=''),
          awsElasticBlockStore: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
            '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
            withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
          },
          '#azureDisk':: d.obj(help=''),
          azureDisk: {
            '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
            withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
            '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
            withDiskName(diskName): { azureDisk+: { diskName: diskName } },
            '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
            withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { azureDisk+: { fsType: fsType } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { azureDisk+: { kind: kind } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
          },
          '#azureFile':: d.obj(help=''),
          azureFile: {
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
            '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { azureFile+: { secretName: secretName } },
            '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
            withShareName(shareName): { azureFile+: { shareName: shareName } },
          },
          '#cephfs':: d.obj(help=''),
          cephfs: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cephfs+: { secretRef+: { name: name } } },
            },
            '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { cephfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
            '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
            withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { cephfs+: { user: user } },
          },
          '#cinder':: d.obj(help=''),
          cinder: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cinder+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { cinder+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
          },
          '#configMap':: d.obj(help=''),
          configMap: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMap+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMap+: { optional: optional } },
          },
          '#csi':: d.obj(help=''),
          csi: {
            '#nodePublishSecretRef':: d.obj(help=''),
            nodePublishSecretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
            },
            '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
            withDriver(driver): { csi+: { driver: driver } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { csi+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
            '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
            withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
            '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
            withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
          },
          '#downwardAPI':: d.obj(help=''),
          downwardAPI: {
            '#items':: d.obj(help=''),
            items: {
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { resourceFieldRef+: { resource: resource } },
              },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
          },
          '#emptyDir':: d.obj(help=''),
          emptyDir: {
            '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
            withMedium(medium): { emptyDir+: { medium: medium } },
            '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
            withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
          },
          '#ephemeral':: d.obj(help=''),
          ephemeral: {
            '#volumeClaimTemplate':: d.obj(help=''),
            volumeClaimTemplate: {
              '#spec':: d.obj(help=''),
              spec: {
                '#dataSource':: d.obj(help=''),
                dataSource: {
                  '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                  withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                  '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                  withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                  '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
                },
                '#resources':: d.obj(help=''),
                resources: {
                  '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                  withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                  '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                  withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                  '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                  withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                  '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                  withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
                },
                '#selector':: d.obj(help=''),
                selector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
                },
                '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
                withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
                '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
                withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
                '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
                withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
                '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
                withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
                '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
                withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
              },
              '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
              '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
            },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
          },
          '#fc':: d.obj(help=''),
          fc: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { fc+: { fsType: fsType } },
            '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
            withLun(lun): { fc+: { lun: lun } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
            '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
            withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
            '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
            withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
            '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
            withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
            '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
            withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
          },
          '#flexVolume':: d.obj(help=''),
          flexVolume: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { flexVolume+: { secretRef+: { name: name } } },
            },
            '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
            withDriver(driver): { flexVolume+: { driver: driver } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { flexVolume+: { fsType: fsType } },
            '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
            withOptions(options): { flexVolume+: { options: options } },
            '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
            withOptionsMixin(options): { flexVolume+: { options+: options } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
          },
          '#flocker':: d.obj(help=''),
          flocker: {
            '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
            withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
            '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
            withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
          },
          '#gcePersistentDisk':: d.obj(help=''),
          gcePersistentDisk: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
            '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
            withPartition(partition): { gcePersistentDisk+: { partition: partition } },
            '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
            withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
          },
          '#gitRepo':: d.obj(help=''),
          gitRepo: {
            '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
            withDirectory(directory): { gitRepo+: { directory: directory } },
            '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
            withRepository(repository): { gitRepo+: { repository: repository } },
            '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
            withRevision(revision): { gitRepo+: { revision: revision } },
          },
          '#glusterfs':: d.obj(help=''),
          glusterfs: {
            '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
            withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { glusterfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
          },
          '#hostPath':: d.obj(help=''),
          hostPath: {
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { hostPath+: { path: path } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { hostPath+: { type: type } },
          },
          '#iscsi':: d.obj(help=''),
          iscsi: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { iscsi+: { secretRef+: { name: name } } },
            },
            '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
            withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
            '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
            withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { iscsi+: { fsType: fsType } },
            '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
            withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
            '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
            withIqn(iqn): { iscsi+: { iqn: iqn } },
            '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
            withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
            '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
            withLun(lun): { iscsi+: { lun: lun } },
            '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
            withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
            '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
            withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
            '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
            withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
          },
          '#nfs':: d.obj(help=''),
          nfs: {
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { nfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
            '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
            withServer(server): { nfs+: { server: server } },
          },
          '#persistentVolumeClaim':: d.obj(help=''),
          persistentVolumeClaim: {
            '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
            withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
          },
          '#photonPersistentDisk':: d.obj(help=''),
          photonPersistentDisk: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
            '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
            withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
          },
          '#portworxVolume':: d.obj(help=''),
          portworxVolume: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { portworxVolume+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
          },
          '#projected':: d.obj(help=''),
          projected: {
            '#sources':: d.obj(help=''),
            sources: {
              '#configMap':: d.obj(help=''),
              configMap: {
                '#items':: d.obj(help=''),
                items: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { configMap+: { name: name } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { configMap+: { optional: optional } },
              },
              '#downwardAPI':: d.obj(help=''),
              downwardAPI: {
                '#items':: d.obj(help=''),
                items: {
                  '#fieldRef':: d.obj(help=''),
                  fieldRef: {
                    '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                    withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                    '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                    withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                  },
                  '#resourceFieldRef':: d.obj(help=''),
                  resourceFieldRef: {
                    '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                    withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                    '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                    withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                    '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                    withResource(resource): { resourceFieldRef+: { resource: resource } },
                  },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
              },
              '#secret':: d.obj(help=''),
              secret: {
                '#items':: d.obj(help=''),
                items: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { secret+: { name: name } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { secret+: { optional: optional } },
              },
              '#serviceAccountToken':: d.obj(help=''),
              serviceAccountToken: {
                '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
                withAudience(audience): { serviceAccountToken+: { audience: audience } },
                '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
                withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { serviceAccountToken+: { path: path } },
              },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
            '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
            withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
            '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
            withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
          },
          '#quobyte':: d.obj(help=''),
          quobyte: {
            '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
            withGroup(group): { quobyte+: { group: group } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
            '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
            withRegistry(registry): { quobyte+: { registry: registry } },
            '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
            withTenant(tenant): { quobyte+: { tenant: tenant } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { quobyte+: { user: user } },
            '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
            withVolume(volume): { quobyte+: { volume: volume } },
          },
          '#rbd':: d.obj(help=''),
          rbd: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { rbd+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { rbd+: { fsType: fsType } },
            '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
            withImage(image): { rbd+: { image: image } },
            '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
            withKeyring(keyring): { rbd+: { keyring: keyring } },
            '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
            withPool(pool): { rbd+: { pool: pool } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { rbd+: { user: user } },
          },
          '#scaleIO':: d.obj(help=''),
          scaleIO: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { scaleIO+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { scaleIO+: { fsType: fsType } },
            '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
            withGateway(gateway): { scaleIO+: { gateway: gateway } },
            '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
            withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
            '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
            withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
            '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
            withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
            '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
            withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
            '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
            withSystem(system): { scaleIO+: { system: system } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
          },
          '#secret':: d.obj(help=''),
          secret: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secret+: { optional: optional } },
            '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { secret+: { secretName: secretName } },
          },
          '#storageos':: d.obj(help=''),
          storageos: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { storageos+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { storageos+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
            '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
            withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
          },
          '#vsphereVolume':: d.obj(help=''),
          vsphereVolume: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
            '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
            withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
            '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
            withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
            '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
            withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { spec+: { storage+: { esIndexCleaner+: { annotations: annotations } } } },
        '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { spec+: { storage+: { esIndexCleaner+: { annotations+: annotations } } } },
        '#withBackoffLimit':: d.fn(help='', args=[d.arg(name='backoffLimit', type=d.T.integer)]),
        withBackoffLimit(backoffLimit): { spec+: { storage+: { esIndexCleaner+: { backoffLimit: backoffLimit } } } },
        '#withEnabled':: d.fn(help='', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { storage+: { esIndexCleaner+: { enabled: enabled } } } },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { spec+: { storage+: { esIndexCleaner+: { image: image } } } },
        '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { spec+: { storage+: { esIndexCleaner+: { labels: labels } } } },
        '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { spec+: { storage+: { esIndexCleaner+: { labels+: labels } } } },
        '#withNumberOfDays':: d.fn(help='', args=[d.arg(name='numberOfDays', type=d.T.integer)]),
        withNumberOfDays(numberOfDays): { spec+: { storage+: { esIndexCleaner+: { numberOfDays: numberOfDays } } } },
        '#withSchedule':: d.fn(help='', args=[d.arg(name='schedule', type=d.T.string)]),
        withSchedule(schedule): { spec+: { storage+: { esIndexCleaner+: { schedule: schedule } } } },
        '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
        withServiceAccount(serviceAccount): { spec+: { storage+: { esIndexCleaner+: { serviceAccount: serviceAccount } } } },
        '#withSuccessfulJobsHistoryLimit':: d.fn(help='', args=[d.arg(name='successfulJobsHistoryLimit', type=d.T.integer)]),
        withSuccessfulJobsHistoryLimit(successfulJobsHistoryLimit): { spec+: { storage+: { esIndexCleaner+: { successfulJobsHistoryLimit: successfulJobsHistoryLimit } } } },
        '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerations(tolerations): { spec+: { storage+: { esIndexCleaner+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerationsMixin(tolerations): { spec+: { storage+: { esIndexCleaner+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTtlSecondsAfterFinished':: d.fn(help='', args=[d.arg(name='ttlSecondsAfterFinished', type=d.T.integer)]),
        withTtlSecondsAfterFinished(ttlSecondsAfterFinished): { spec+: { storage+: { esIndexCleaner+: { ttlSecondsAfterFinished: ttlSecondsAfterFinished } } } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { spec+: { storage+: { esIndexCleaner+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { spec+: { storage+: { esIndexCleaner+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } } },
        '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
        withVolumes(volumes): { spec+: { storage+: { esIndexCleaner+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } } },
        '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
        withVolumesMixin(volumes): { spec+: { storage+: { esIndexCleaner+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } } },
      },
      '#esRollover':: d.obj(help=''),
      esRollover: {
        '#affinity':: d.obj(help=''),
        affinity: {
          '#nodeAffinity':: d.obj(help=''),
          nodeAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#preference':: d.obj(help=''),
              preference: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#nodeSelectorTerms':: d.obj(help=''),
              nodeSelectorTerms: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#matchFields':: d.obj(help=''),
                matchFields: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
                '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
                '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
                withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              },
              '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTerms(nodeSelectorTerms): { spec+: { storage+: { esRollover+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
              '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
              withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { storage+: { esRollover+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } } },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAffinity':: d.obj(help=''),
          podAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
          '#podAntiAffinity':: d.obj(help=''),
          podAntiAffinity: {
            '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            preferredDuringSchedulingIgnoredDuringExecution: {
              '#podAffinityTerm':: d.obj(help=''),
              podAffinityTerm: {
                '#labelSelector':: d.obj(help=''),
                labelSelector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
                },
                '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
                withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
                '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
                withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
              },
              '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
              withWeight(weight): { weight: weight },
            },
            '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
            requiredDuringSchedulingIgnoredDuringExecution: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
              },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { topologyKey: topologyKey },
            },
            '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
            '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
            withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { storage+: { esRollover+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } } },
          },
        },
        '#resources':: d.obj(help=''),
        resources: {
          '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { spec+: { storage+: { esRollover+: { resources+: { limits: limits } } } } },
          '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { spec+: { storage+: { esRollover+: { resources+: { limits+: limits } } } } },
          '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { spec+: { storage+: { esRollover+: { resources+: { requests: requests } } } } },
          '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { spec+: { storage+: { esRollover+: { resources+: { requests+: requests } } } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { spec+: { storage+: { esRollover+: { securityContext+: { seLinuxOptions+: { level: level } } } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { spec+: { storage+: { esRollover+: { securityContext+: { seLinuxOptions+: { role: role } } } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { spec+: { storage+: { esRollover+: { securityContext+: { seLinuxOptions+: { type: type } } } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { spec+: { storage+: { esRollover+: { securityContext+: { seLinuxOptions+: { user: user } } } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { spec+: { storage+: { esRollover+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { spec+: { storage+: { esRollover+: { securityContext+: { seccompProfile+: { type: type } } } } } },
          },
          '#sysctls':: d.obj(help=''),
          sysctls: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { storage+: { esRollover+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { storage+: { esRollover+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { spec+: { storage+: { esRollover+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } } },
          },
          '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
          withFsGroup(fsGroup): { spec+: { storage+: { esRollover+: { securityContext+: { fsGroup: fsGroup } } } } },
          '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
          withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { storage+: { esRollover+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { spec+: { storage+: { esRollover+: { securityContext+: { runAsGroup: runAsGroup } } } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { spec+: { storage+: { esRollover+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { spec+: { storage+: { esRollover+: { securityContext+: { runAsUser: runAsUser } } } } },
          '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
          withSupplementalGroups(supplementalGroups): { spec+: { storage+: { esRollover+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } } },
          '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
          withSupplementalGroupsMixin(supplementalGroups): { spec+: { storage+: { esRollover+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } } },
          '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
          withSysctls(sysctls): { spec+: { storage+: { esRollover+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } } },
          '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
          withSysctlsMixin(sysctls): { spec+: { storage+: { esRollover+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } } },
        },
        '#tolerations':: d.obj(help=''),
        tolerations: {
          '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
          withEffect(effect): { effect: effect },
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
          withOperator(operator): { operator: operator },
          '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
          withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#volumes':: d.obj(help=''),
        volumes: {
          '#awsElasticBlockStore':: d.obj(help=''),
          awsElasticBlockStore: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
            '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
            withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
          },
          '#azureDisk':: d.obj(help=''),
          azureDisk: {
            '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
            withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
            '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
            withDiskName(diskName): { azureDisk+: { diskName: diskName } },
            '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
            withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { azureDisk+: { fsType: fsType } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { azureDisk+: { kind: kind } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
          },
          '#azureFile':: d.obj(help=''),
          azureFile: {
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
            '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { azureFile+: { secretName: secretName } },
            '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
            withShareName(shareName): { azureFile+: { shareName: shareName } },
          },
          '#cephfs':: d.obj(help=''),
          cephfs: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cephfs+: { secretRef+: { name: name } } },
            },
            '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { cephfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
            '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
            withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { cephfs+: { user: user } },
          },
          '#cinder':: d.obj(help=''),
          cinder: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cinder+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { cinder+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
          },
          '#configMap':: d.obj(help=''),
          configMap: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMap+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMap+: { optional: optional } },
          },
          '#csi':: d.obj(help=''),
          csi: {
            '#nodePublishSecretRef':: d.obj(help=''),
            nodePublishSecretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
            },
            '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
            withDriver(driver): { csi+: { driver: driver } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { csi+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
            '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
            withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
            '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
            withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
          },
          '#downwardAPI':: d.obj(help=''),
          downwardAPI: {
            '#items':: d.obj(help=''),
            items: {
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { resourceFieldRef+: { resource: resource } },
              },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
          },
          '#emptyDir':: d.obj(help=''),
          emptyDir: {
            '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
            withMedium(medium): { emptyDir+: { medium: medium } },
            '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
            withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
          },
          '#ephemeral':: d.obj(help=''),
          ephemeral: {
            '#volumeClaimTemplate':: d.obj(help=''),
            volumeClaimTemplate: {
              '#spec':: d.obj(help=''),
              spec: {
                '#dataSource':: d.obj(help=''),
                dataSource: {
                  '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                  withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                  '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                  withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                  '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
                },
                '#resources':: d.obj(help=''),
                resources: {
                  '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                  withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                  '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                  withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                  '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                  withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                  '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                  withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
                },
                '#selector':: d.obj(help=''),
                selector: {
                  '#matchExpressions':: d.obj(help=''),
                  matchExpressions: {
                    '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                    withKey(key): { key: key },
                    '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                    withOperator(operator): { operator: operator },
                    '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                    withValues(values): { values: if std.isArray(v=values) then values else [values] },
                    '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                    withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                  },
                  '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                  '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                  withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                  '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                  '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                  withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
                },
                '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
                withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
                '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
                withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
                '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
                withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
                '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
                withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
                '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
                withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
              },
              '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
              '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
              withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
            },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
          },
          '#fc':: d.obj(help=''),
          fc: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { fc+: { fsType: fsType } },
            '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
            withLun(lun): { fc+: { lun: lun } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
            '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
            withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
            '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
            withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
            '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
            withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
            '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
            withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
          },
          '#flexVolume':: d.obj(help=''),
          flexVolume: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { flexVolume+: { secretRef+: { name: name } } },
            },
            '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
            withDriver(driver): { flexVolume+: { driver: driver } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { flexVolume+: { fsType: fsType } },
            '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
            withOptions(options): { flexVolume+: { options: options } },
            '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
            withOptionsMixin(options): { flexVolume+: { options+: options } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
          },
          '#flocker':: d.obj(help=''),
          flocker: {
            '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
            withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
            '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
            withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
          },
          '#gcePersistentDisk':: d.obj(help=''),
          gcePersistentDisk: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
            '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
            withPartition(partition): { gcePersistentDisk+: { partition: partition } },
            '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
            withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
          },
          '#gitRepo':: d.obj(help=''),
          gitRepo: {
            '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
            withDirectory(directory): { gitRepo+: { directory: directory } },
            '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
            withRepository(repository): { gitRepo+: { repository: repository } },
            '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
            withRevision(revision): { gitRepo+: { revision: revision } },
          },
          '#glusterfs':: d.obj(help=''),
          glusterfs: {
            '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
            withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { glusterfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
          },
          '#hostPath':: d.obj(help=''),
          hostPath: {
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { hostPath+: { path: path } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { hostPath+: { type: type } },
          },
          '#iscsi':: d.obj(help=''),
          iscsi: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { iscsi+: { secretRef+: { name: name } } },
            },
            '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
            withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
            '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
            withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { iscsi+: { fsType: fsType } },
            '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
            withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
            '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
            withIqn(iqn): { iscsi+: { iqn: iqn } },
            '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
            withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
            '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
            withLun(lun): { iscsi+: { lun: lun } },
            '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
            withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
            '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
            withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
            '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
            withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
          },
          '#nfs':: d.obj(help=''),
          nfs: {
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { nfs+: { path: path } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
            '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
            withServer(server): { nfs+: { server: server } },
          },
          '#persistentVolumeClaim':: d.obj(help=''),
          persistentVolumeClaim: {
            '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
            withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
          },
          '#photonPersistentDisk':: d.obj(help=''),
          photonPersistentDisk: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
            '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
            withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
          },
          '#portworxVolume':: d.obj(help=''),
          portworxVolume: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { portworxVolume+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
            '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
            withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
          },
          '#projected':: d.obj(help=''),
          projected: {
            '#sources':: d.obj(help=''),
            sources: {
              '#configMap':: d.obj(help=''),
              configMap: {
                '#items':: d.obj(help=''),
                items: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { configMap+: { name: name } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { configMap+: { optional: optional } },
              },
              '#downwardAPI':: d.obj(help=''),
              downwardAPI: {
                '#items':: d.obj(help=''),
                items: {
                  '#fieldRef':: d.obj(help=''),
                  fieldRef: {
                    '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                    withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                    '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                    withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                  },
                  '#resourceFieldRef':: d.obj(help=''),
                  resourceFieldRef: {
                    '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                    withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                    '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                    withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                    '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                    withResource(resource): { resourceFieldRef+: { resource: resource } },
                  },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
              },
              '#secret':: d.obj(help=''),
              secret: {
                '#items':: d.obj(help=''),
                items: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                  withMode(mode): { mode: mode },
                  '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                  withPath(path): { path: path },
                },
                '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
                withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
                '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
                withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { secret+: { name: name } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { secret+: { optional: optional } },
              },
              '#serviceAccountToken':: d.obj(help=''),
              serviceAccountToken: {
                '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
                withAudience(audience): { serviceAccountToken+: { audience: audience } },
                '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
                withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { serviceAccountToken+: { path: path } },
              },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
            '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
            withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
            '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
            withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
          },
          '#quobyte':: d.obj(help=''),
          quobyte: {
            '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
            withGroup(group): { quobyte+: { group: group } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
            '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
            withRegistry(registry): { quobyte+: { registry: registry } },
            '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
            withTenant(tenant): { quobyte+: { tenant: tenant } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { quobyte+: { user: user } },
            '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
            withVolume(volume): { quobyte+: { volume: volume } },
          },
          '#rbd':: d.obj(help=''),
          rbd: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { rbd+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { rbd+: { fsType: fsType } },
            '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
            withImage(image): { rbd+: { image: image } },
            '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
            withKeyring(keyring): { rbd+: { keyring: keyring } },
            '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
            withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
            '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
            withPool(pool): { rbd+: { pool: pool } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { rbd+: { user: user } },
          },
          '#scaleIO':: d.obj(help=''),
          scaleIO: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { scaleIO+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { scaleIO+: { fsType: fsType } },
            '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
            withGateway(gateway): { scaleIO+: { gateway: gateway } },
            '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
            withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
            '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
            withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
            '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
            withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
            '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
            withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
            '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
            withSystem(system): { scaleIO+: { system: system } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
          },
          '#secret':: d.obj(help=''),
          secret: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
            withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secret+: { optional: optional } },
            '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { secret+: { secretName: secretName } },
          },
          '#storageos':: d.obj(help=''),
          storageos: {
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { storageos+: { secretRef+: { name: name } } },
            },
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { storageos+: { fsType: fsType } },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
            '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
            withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
          },
          '#vsphereVolume':: d.obj(help=''),
          vsphereVolume: {
            '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
            withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
            '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
            withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
            '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
            withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
            '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
            withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { spec+: { storage+: { esRollover+: { annotations: annotations } } } },
        '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { spec+: { storage+: { esRollover+: { annotations+: annotations } } } },
        '#withBackoffLimit':: d.fn(help='', args=[d.arg(name='backoffLimit', type=d.T.integer)]),
        withBackoffLimit(backoffLimit): { spec+: { storage+: { esRollover+: { backoffLimit: backoffLimit } } } },
        '#withConditions':: d.fn(help='', args=[d.arg(name='conditions', type=d.T.string)]),
        withConditions(conditions): { spec+: { storage+: { esRollover+: { conditions: conditions } } } },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { spec+: { storage+: { esRollover+: { image: image } } } },
        '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { spec+: { storage+: { esRollover+: { labels: labels } } } },
        '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { spec+: { storage+: { esRollover+: { labels+: labels } } } },
        '#withReadTTL':: d.fn(help='', args=[d.arg(name='readTTL', type=d.T.string)]),
        withReadTTL(readTTL): { spec+: { storage+: { esRollover+: { readTTL: readTTL } } } },
        '#withSchedule':: d.fn(help='', args=[d.arg(name='schedule', type=d.T.string)]),
        withSchedule(schedule): { spec+: { storage+: { esRollover+: { schedule: schedule } } } },
        '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
        withServiceAccount(serviceAccount): { spec+: { storage+: { esRollover+: { serviceAccount: serviceAccount } } } },
        '#withSuccessfulJobsHistoryLimit':: d.fn(help='', args=[d.arg(name='successfulJobsHistoryLimit', type=d.T.integer)]),
        withSuccessfulJobsHistoryLimit(successfulJobsHistoryLimit): { spec+: { storage+: { esRollover+: { successfulJobsHistoryLimit: successfulJobsHistoryLimit } } } },
        '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerations(tolerations): { spec+: { storage+: { esRollover+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
        withTolerationsMixin(tolerations): { spec+: { storage+: { esRollover+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } } },
        '#withTtlSecondsAfterFinished':: d.fn(help='', args=[d.arg(name='ttlSecondsAfterFinished', type=d.T.integer)]),
        withTtlSecondsAfterFinished(ttlSecondsAfterFinished): { spec+: { storage+: { esRollover+: { ttlSecondsAfterFinished: ttlSecondsAfterFinished } } } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { spec+: { storage+: { esRollover+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { spec+: { storage+: { esRollover+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } } },
        '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
        withVolumes(volumes): { spec+: { storage+: { esRollover+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } } },
        '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
        withVolumesMixin(volumes): { spec+: { storage+: { esRollover+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } } },
      },
      '#grpcPlugin':: d.obj(help=''),
      grpcPlugin: {
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { spec+: { storage+: { grpcPlugin+: { image: image } } } },
      },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { storage+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { storage+: { options+: options } } },
      '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
      withSecretName(secretName): { spec+: { storage+: { secretName: secretName } } },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { spec+: { storage+: { type: type } } },
    },
    '#tolerations':: d.obj(help=''),
    tolerations: {
      '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
      withEffect(effect): { effect: effect },
      '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { key: key },
      '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
      withOperator(operator): { operator: operator },
      '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
      withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
      '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
      withValue(value): { value: value },
    },
    '#ui':: d.obj(help=''),
    ui: {
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
      withOptions(options): { spec+: { ui+: { options: options } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
      withOptionsMixin(options): { spec+: { ui+: { options+: options } } },
    },
    '#volumeMounts':: d.obj(help=''),
    volumeMounts: {
      '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
      withMountPath(mountPath): { mountPath: mountPath },
      '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
      withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
      withReadOnly(readOnly): { readOnly: readOnly },
      '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
      withSubPath(subPath): { subPath: subPath },
      '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
      withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
    },
    '#volumes':: d.obj(help=''),
    volumes: {
      '#awsElasticBlockStore':: d.obj(help=''),
      awsElasticBlockStore: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
        '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
        withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
        '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
        withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
      },
      '#azureDisk':: d.obj(help=''),
      azureDisk: {
        '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
        withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
        '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
        withDiskName(diskName): { azureDisk+: { diskName: diskName } },
        '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
        withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { azureDisk+: { fsType: fsType } },
        '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
        withKind(kind): { azureDisk+: { kind: kind } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
      },
      '#azureFile':: d.obj(help=''),
      azureFile: {
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
        '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
        withSecretName(secretName): { azureFile+: { secretName: secretName } },
        '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
        withShareName(shareName): { azureFile+: { shareName: shareName } },
      },
      '#cephfs':: d.obj(help=''),
      cephfs: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { cephfs+: { secretRef+: { name: name } } },
        },
        '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { cephfs+: { path: path } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
        '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
        withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { cephfs+: { user: user } },
      },
      '#cinder':: d.obj(help=''),
      cinder: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { cinder+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { cinder+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
        '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
        withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
      },
      '#configMap':: d.obj(help=''),
      configMap: {
        '#items':: d.obj(help=''),
        items: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
        '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
        withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
        '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
        withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { configMap+: { name: name } },
        '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { configMap+: { optional: optional } },
      },
      '#csi':: d.obj(help=''),
      csi: {
        '#nodePublishSecretRef':: d.obj(help=''),
        nodePublishSecretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
        },
        '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
        withDriver(driver): { csi+: { driver: driver } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { csi+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
        '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
        withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
        '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
        withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
      },
      '#downwardAPI':: d.obj(help=''),
      downwardAPI: {
        '#items':: d.obj(help=''),
        items: {
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { resourceFieldRef+: { resource: resource } },
          },
          '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
        '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
        withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
        '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
        withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
      },
      '#emptyDir':: d.obj(help=''),
      emptyDir: {
        '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
        withMedium(medium): { emptyDir+: { medium: medium } },
        '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
        withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
      },
      '#ephemeral':: d.obj(help=''),
      ephemeral: {
        '#volumeClaimTemplate':: d.obj(help=''),
        volumeClaimTemplate: {
          '#spec':: d.obj(help=''),
          spec: {
            '#dataSource':: d.obj(help=''),
            dataSource: {
              '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
              withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
              '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
              withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
            },
            '#resources':: d.obj(help=''),
            resources: {
              '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
              withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
              '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
              withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
              '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
              withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
              '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
              withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
            },
            '#selector':: d.obj(help=''),
            selector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
            },
            '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
            withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
            '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
            withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
            '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
            withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
            '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
            withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
          },
          '#withMetadata':: d.fn(help='', args=[d.arg(name='metadata', type=d.T.object)]),
          withMetadata(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata: metadata } } },
          '#withMetadataMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metadata', type=d.T.object)]),
          withMetadataMixin(metadata): { ephemeral+: { volumeClaimTemplate+: { metadata+: metadata } } },
        },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { ephemeral+: { readOnly: readOnly } },
      },
      '#fc':: d.obj(help=''),
      fc: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { fc+: { fsType: fsType } },
        '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
        withLun(lun): { fc+: { lun: lun } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
        '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
        withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
        '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
        withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
        '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
        withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
        '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
        withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
      },
      '#flexVolume':: d.obj(help=''),
      flexVolume: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { flexVolume+: { secretRef+: { name: name } } },
        },
        '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
        withDriver(driver): { flexVolume+: { driver: driver } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { flexVolume+: { fsType: fsType } },
        '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
        withOptions(options): { flexVolume+: { options: options } },
        '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
        withOptionsMixin(options): { flexVolume+: { options+: options } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
      },
      '#flocker':: d.obj(help=''),
      flocker: {
        '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
        withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
        '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
        withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
      },
      '#gcePersistentDisk':: d.obj(help=''),
      gcePersistentDisk: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
        '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
        withPartition(partition): { gcePersistentDisk+: { partition: partition } },
        '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
        withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
      },
      '#gitRepo':: d.obj(help=''),
      gitRepo: {
        '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
        withDirectory(directory): { gitRepo+: { directory: directory } },
        '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
        withRepository(repository): { gitRepo+: { repository: repository } },
        '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
        withRevision(revision): { gitRepo+: { revision: revision } },
      },
      '#glusterfs':: d.obj(help=''),
      glusterfs: {
        '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
        withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { glusterfs+: { path: path } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
      },
      '#hostPath':: d.obj(help=''),
      hostPath: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { hostPath+: { path: path } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { hostPath+: { type: type } },
      },
      '#iscsi':: d.obj(help=''),
      iscsi: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { iscsi+: { secretRef+: { name: name } } },
        },
        '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
        withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
        '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
        withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { iscsi+: { fsType: fsType } },
        '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
        withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
        '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
        withIqn(iqn): { iscsi+: { iqn: iqn } },
        '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
        withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
        '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
        withLun(lun): { iscsi+: { lun: lun } },
        '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
        withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
        '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
        withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
        '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
        withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
      },
      '#nfs':: d.obj(help=''),
      nfs: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { nfs+: { path: path } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
        '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
        withServer(server): { nfs+: { server: server } },
      },
      '#persistentVolumeClaim':: d.obj(help=''),
      persistentVolumeClaim: {
        '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
        withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
      },
      '#photonPersistentDisk':: d.obj(help=''),
      photonPersistentDisk: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
        '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
        withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
      },
      '#portworxVolume':: d.obj(help=''),
      portworxVolume: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { portworxVolume+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
        '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
        withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
      },
      '#projected':: d.obj(help=''),
      projected: {
        '#sources':: d.obj(help=''),
        sources: {
          '#configMap':: d.obj(help=''),
          configMap: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMap+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMap+: { optional: optional } },
          },
          '#downwardAPI':: d.obj(help=''),
          downwardAPI: {
            '#items':: d.obj(help=''),
            items: {
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { resourceFieldRef+: { resource: resource } },
              },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
          },
          '#secret':: d.obj(help=''),
          secret: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secret+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secret+: { optional: optional } },
          },
          '#serviceAccountToken':: d.obj(help=''),
          serviceAccountToken: {
            '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
            withAudience(audience): { serviceAccountToken+: { audience: audience } },
            '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
            withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { serviceAccountToken+: { path: path } },
          },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
        '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
        withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
        '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
        withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
      },
      '#quobyte':: d.obj(help=''),
      quobyte: {
        '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
        withGroup(group): { quobyte+: { group: group } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
        '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
        withRegistry(registry): { quobyte+: { registry: registry } },
        '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
        withTenant(tenant): { quobyte+: { tenant: tenant } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { quobyte+: { user: user } },
        '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
        withVolume(volume): { quobyte+: { volume: volume } },
      },
      '#rbd':: d.obj(help=''),
      rbd: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { rbd+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { rbd+: { fsType: fsType } },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { rbd+: { image: image } },
        '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
        withKeyring(keyring): { rbd+: { keyring: keyring } },
        '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
        withPool(pool): { rbd+: { pool: pool } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { rbd+: { user: user } },
      },
      '#scaleIO':: d.obj(help=''),
      scaleIO: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { scaleIO+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { scaleIO+: { fsType: fsType } },
        '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
        withGateway(gateway): { scaleIO+: { gateway: gateway } },
        '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
        withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
        '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
        withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
        '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
        withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
        '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
        withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
        '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
        withSystem(system): { scaleIO+: { system: system } },
        '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
        withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
      },
      '#secret':: d.obj(help=''),
      secret: {
        '#items':: d.obj(help=''),
        items: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
        '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
        withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
        '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
        withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
        '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { secret+: { optional: optional } },
        '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
        withSecretName(secretName): { secret+: { secretName: secretName } },
      },
      '#storageos':: d.obj(help=''),
      storageos: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { storageos+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { storageos+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
        '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
        withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
        '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
        withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
      },
      '#vsphereVolume':: d.obj(help=''),
      vsphereVolume: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
        '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
        withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
        '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
        withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
        '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
        withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
      },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
    },
    '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { spec+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { spec+: { annotations+: annotations } },
    '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { spec+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { spec+: { labels+: labels } },
    '#withServiceAccount':: d.fn(help='', args=[d.arg(name='serviceAccount', type=d.T.string)]),
    withServiceAccount(serviceAccount): { spec+: { serviceAccount: serviceAccount } },
    '#withStrategy':: d.fn(help='', args=[d.arg(name='strategy', type=d.T.string)]),
    withStrategy(strategy): { spec+: { strategy: strategy } },
    '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
    withTolerations(tolerations): { spec+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } },
    '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
    withTolerationsMixin(tolerations): { spec+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } },
    '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
    withVolumeMounts(volumeMounts): { spec+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
    '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
    withVolumeMountsMixin(volumeMounts): { spec+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
    '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
    withVolumes(volumes): { spec+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } },
    '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
    withVolumesMixin(volumes): { spec+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } },
  },
  '#mixin': 'ignore',
  mixin: self,
}

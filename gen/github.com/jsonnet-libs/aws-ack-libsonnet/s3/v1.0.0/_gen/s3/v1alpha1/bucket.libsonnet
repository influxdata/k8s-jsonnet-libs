{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='bucket', url='', help='"Bucket is the Schema for the Buckets API"'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Bucket', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 's3.services.k8s.aws/v1alpha1',
    kind: 'Bucket',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"BucketSpec defines the desired state of Bucket. \\n In terms of implementation, a Bucket is a resource. An Amazon S3 bucket name is globally unique, and the namespace is shared by all Amazon Web Services accounts."'),
  spec: {
    '#accelerate':: d.obj(help='"Container for setting the transfer acceleration state."'),
    accelerate: {},
    '#analytics':: d.obj(help=''),
    analytics: {
      '#filter':: d.obj(help='"The filter used to describe a set of objects for analyses. A filter must have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided, all objects will be considered in any analysis."'),
      filter: {
        '#and':: d.obj(help='"A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates in any combination, and an object must match all of the predicates for the filter to apply."'),
        and: {
          '#tags':: d.obj(help=''),
          tags: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { filter+: { and+: { prefix: prefix } } },
          '#withTags':: d.fn(help='', args=[d.arg(name='tags', type=d.T.array)]),
          withTags(tags): { filter+: { and+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
          '#withTagsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
          withTagsMixin(tags): { filter+: { and+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
        },
        '#tag':: d.obj(help='"A container of a key value name pair."'),
        tag: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { filter+: { tag+: { key: key } } },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { filter+: { tag+: { value: value } } },
        },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { filter+: { prefix: prefix } },
      },
      '#storageClassAnalysis':: d.obj(help='"Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket."'),
      storageClassAnalysis: {
        '#dataExport':: d.obj(help='"Container for data related to the storage class analysis for an Amazon S3 bucket for export."'),
        dataExport: {
          '#destination':: d.obj(help='"Where to publish the analytics results."'),
          destination: {
            '#s3BucketDestination':: d.obj(help='"Contains information about where to publish the analytics results."'),
            s3BucketDestination: {
              '#withBucket':: d.fn(help='', args=[d.arg(name='bucket', type=d.T.string)]),
              withBucket(bucket): { storageClassAnalysis+: { dataExport+: { destination+: { s3BucketDestination+: { bucket: bucket } } } } },
              '#withBucketAccountID':: d.fn(help='', args=[d.arg(name='bucketAccountID', type=d.T.string)]),
              withBucketAccountID(bucketAccountID): { storageClassAnalysis+: { dataExport+: { destination+: { s3BucketDestination+: { bucketAccountID: bucketAccountID } } } } },
              '#withFormat':: d.fn(help='', args=[d.arg(name='format', type=d.T.string)]),
              withFormat(format): { storageClassAnalysis+: { dataExport+: { destination+: { s3BucketDestination+: { format: format } } } } },
              '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
              withPrefix(prefix): { storageClassAnalysis+: { dataExport+: { destination+: { s3BucketDestination+: { prefix: prefix } } } } },
            },
          },
          '#withOutputSchemaVersion':: d.fn(help='', args=[d.arg(name='outputSchemaVersion', type=d.T.string)]),
          withOutputSchemaVersion(outputSchemaVersion): { storageClassAnalysis+: { dataExport+: { outputSchemaVersion: outputSchemaVersion } } },
        },
      },
      '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
      withId(id): { id: id },
    },
    '#cors':: d.obj(help='"Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see Enabling Cross-Origin Resource Sharing (https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon S3 User Guide."'),
    cors: {
      '#corsRules':: d.obj(help=''),
      corsRules: {
        '#withAllowedHeaders':: d.fn(help='', args=[d.arg(name='allowedHeaders', type=d.T.array)]),
        withAllowedHeaders(allowedHeaders): { allowedHeaders: if std.isArray(v=allowedHeaders) then allowedHeaders else [allowedHeaders] },
        '#withAllowedHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedHeaders', type=d.T.array)]),
        withAllowedHeadersMixin(allowedHeaders): { allowedHeaders+: if std.isArray(v=allowedHeaders) then allowedHeaders else [allowedHeaders] },
        '#withAllowedMethods':: d.fn(help='', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethods(allowedMethods): { allowedMethods: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withAllowedMethodsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethodsMixin(allowedMethods): { allowedMethods+: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withAllowedOrigins':: d.fn(help='', args=[d.arg(name='allowedOrigins', type=d.T.array)]),
        withAllowedOrigins(allowedOrigins): { allowedOrigins: if std.isArray(v=allowedOrigins) then allowedOrigins else [allowedOrigins] },
        '#withAllowedOriginsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedOrigins', type=d.T.array)]),
        withAllowedOriginsMixin(allowedOrigins): { allowedOrigins+: if std.isArray(v=allowedOrigins) then allowedOrigins else [allowedOrigins] },
        '#withExposeHeaders':: d.fn(help='', args=[d.arg(name='exposeHeaders', type=d.T.array)]),
        withExposeHeaders(exposeHeaders): { exposeHeaders: if std.isArray(v=exposeHeaders) then exposeHeaders else [exposeHeaders] },
        '#withExposeHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='exposeHeaders', type=d.T.array)]),
        withExposeHeadersMixin(exposeHeaders): { exposeHeaders+: if std.isArray(v=exposeHeaders) then exposeHeaders else [exposeHeaders] },
        '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withMaxAgeSeconds':: d.fn(help='', args=[d.arg(name='maxAgeSeconds', type=d.T.integer)]),
        withMaxAgeSeconds(maxAgeSeconds): { maxAgeSeconds: maxAgeSeconds },
      },
      '#withCorsRules':: d.fn(help='', args=[d.arg(name='corsRules', type=d.T.array)]),
      withCorsRules(corsRules): { spec+: { cors+: { corsRules: if std.isArray(v=corsRules) then corsRules else [corsRules] } } },
      '#withCorsRulesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='corsRules', type=d.T.array)]),
      withCorsRulesMixin(corsRules): { spec+: { cors+: { corsRules+: if std.isArray(v=corsRules) then corsRules else [corsRules] } } },
    },
    '#createBucketConfiguration':: d.obj(help='"The configuration information for the bucket."'),
    createBucketConfiguration: {
      '#withLocationConstraint':: d.fn(help='', args=[d.arg(name='locationConstraint', type=d.T.string)]),
      withLocationConstraint(locationConstraint): { spec+: { createBucketConfiguration+: { locationConstraint: locationConstraint } } },
    },
    '#encryption':: d.obj(help='"Specifies the default server-side-encryption configuration."'),
    encryption: {
      '#rules':: d.obj(help=''),
      rules: {
        '#applyServerSideEncryptionByDefault':: d.obj(help="\"Describes the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. If you don't specify a customer managed key at configuration, Amazon S3 automatically creates an Amazon Web Services KMS key in your Amazon Web Services account the first time that you add an object encrypted with SSE-KMS to a bucket. By default, Amazon S3 uses this KMS key for SSE-KMS. For more information, see PUT Bucket encryption (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the Amazon S3 API Reference.\""),
        applyServerSideEncryptionByDefault: {
          '#withKmsMasterKeyID':: d.fn(help='', args=[d.arg(name='kmsMasterKeyID', type=d.T.string)]),
          withKmsMasterKeyID(kmsMasterKeyID): { applyServerSideEncryptionByDefault+: { kmsMasterKeyID: kmsMasterKeyID } },
          '#withSseAlgorithm':: d.fn(help='', args=[d.arg(name='sseAlgorithm', type=d.T.string)]),
          withSseAlgorithm(sseAlgorithm): { applyServerSideEncryptionByDefault+: { sseAlgorithm: sseAlgorithm } },
        },
        '#withBucketKeyEnabled':: d.fn(help='', args=[d.arg(name='bucketKeyEnabled', type=d.T.boolean)]),
        withBucketKeyEnabled(bucketKeyEnabled): { bucketKeyEnabled: bucketKeyEnabled },
      },
      '#withRules':: d.fn(help='', args=[d.arg(name='rules', type=d.T.array)]),
      withRules(rules): { spec+: { encryption+: { rules: if std.isArray(v=rules) then rules else [rules] } } },
      '#withRulesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rules', type=d.T.array)]),
      withRulesMixin(rules): { spec+: { encryption+: { rules+: if std.isArray(v=rules) then rules else [rules] } } },
    },
    '#intelligentTiering':: d.obj(help=''),
    intelligentTiering: {
      '#filter':: d.obj(help='"The Filter is used to identify objects that the S3 Intelligent-Tiering configuration applies to."'),
      filter: {
        '#and':: d.obj(help='"A container for specifying S3 Intelligent-Tiering filters. The filters determine the subset of objects to which the rule applies."'),
        and: {
          '#tags':: d.obj(help=''),
          tags: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { filter+: { and+: { prefix: prefix } } },
          '#withTags':: d.fn(help='', args=[d.arg(name='tags', type=d.T.array)]),
          withTags(tags): { filter+: { and+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
          '#withTagsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
          withTagsMixin(tags): { filter+: { and+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
        },
        '#tag':: d.obj(help='"A container of a key value name pair."'),
        tag: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { filter+: { tag+: { key: key } } },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { filter+: { tag+: { value: value } } },
        },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { filter+: { prefix: prefix } },
      },
      '#tierings':: d.obj(help=''),
      tierings: {
        '#withAccessTier':: d.fn(help='', args=[d.arg(name='accessTier', type=d.T.string)]),
        withAccessTier(accessTier): { accessTier: accessTier },
        '#withDays':: d.fn(help='', args=[d.arg(name='days', type=d.T.integer)]),
        withDays(days): { days: days },
      },
      '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
      withId(id): { id: id },
      '#withTierings':: d.fn(help='', args=[d.arg(name='tierings', type=d.T.array)]),
      withTierings(tierings): { tierings: if std.isArray(v=tierings) then tierings else [tierings] },
      '#withTieringsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tierings', type=d.T.array)]),
      withTieringsMixin(tierings): { tierings+: if std.isArray(v=tierings) then tierings else [tierings] },
    },
    '#inventory':: d.obj(help=''),
    inventory: {
      '#destination':: d.obj(help='"Specifies the inventory configuration for an Amazon S3 bucket."'),
      destination: {
        '#s3BucketDestination':: d.obj(help='"Contains the bucket name, file format, bucket owner (optional), and prefix (optional) where inventory results are published."'),
        s3BucketDestination: {
          '#encryption':: d.obj(help='"Contains the type of server-side encryption used to encrypt the inventory results."'),
          encryption: {
            '#sseKMS':: d.obj(help='"Specifies the use of SSE-KMS to encrypt delivered inventory reports."'),
            sseKMS: {
              '#withKeyID':: d.fn(help='', args=[d.arg(name='keyID', type=d.T.string)]),
              withKeyID(keyID): { destination+: { s3BucketDestination+: { encryption+: { sseKMS+: { keyID: keyID } } } } },
            },
          },
          '#withAccountID':: d.fn(help='', args=[d.arg(name='accountID', type=d.T.string)]),
          withAccountID(accountID): { destination+: { s3BucketDestination+: { accountID: accountID } } },
          '#withBucket':: d.fn(help='', args=[d.arg(name='bucket', type=d.T.string)]),
          withBucket(bucket): { destination+: { s3BucketDestination+: { bucket: bucket } } },
          '#withFormat':: d.fn(help='', args=[d.arg(name='format', type=d.T.string)]),
          withFormat(format): { destination+: { s3BucketDestination+: { format: format } } },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { destination+: { s3BucketDestination+: { prefix: prefix } } },
        },
      },
      '#filter':: d.obj(help="\"Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria.\""),
      filter: {
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { filter+: { prefix: prefix } },
      },
      '#schedule':: d.obj(help='"Specifies the schedule for generating inventory results."'),
      schedule: {
        '#withFrequency':: d.fn(help='', args=[d.arg(name='frequency', type=d.T.string)]),
        withFrequency(frequency): { schedule+: { frequency: frequency } },
      },
      '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
      withId(id): { id: id },
      '#withIncludedObjectVersions':: d.fn(help='', args=[d.arg(name='includedObjectVersions', type=d.T.string)]),
      withIncludedObjectVersions(includedObjectVersions): { includedObjectVersions: includedObjectVersions },
      '#withIsEnabled':: d.fn(help='', args=[d.arg(name='isEnabled', type=d.T.boolean)]),
      withIsEnabled(isEnabled): { isEnabled: isEnabled },
      '#withOptionalFields':: d.fn(help='', args=[d.arg(name='optionalFields', type=d.T.array)]),
      withOptionalFields(optionalFields): { optionalFields: if std.isArray(v=optionalFields) then optionalFields else [optionalFields] },
      '#withOptionalFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='optionalFields', type=d.T.array)]),
      withOptionalFieldsMixin(optionalFields): { optionalFields+: if std.isArray(v=optionalFields) then optionalFields else [optionalFields] },
    },
    '#lifecycle':: d.obj(help='"Container for lifecycle rules. You can add as many as 1,000 rules."'),
    lifecycle: {
      '#rules':: d.obj(help=''),
      rules: {
        '#abortIncompleteMultipartUpload':: d.obj(help='"Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide."'),
        abortIncompleteMultipartUpload: {
          '#withDaysAfterInitiation':: d.fn(help='', args=[d.arg(name='daysAfterInitiation', type=d.T.integer)]),
          withDaysAfterInitiation(daysAfterInitiation): { abortIncompleteMultipartUpload+: { daysAfterInitiation: daysAfterInitiation } },
        },
        '#expiration':: d.obj(help='"Container for the expiration for the lifecycle of the object."'),
        expiration: {
          '#withDate':: d.fn(help='', args=[d.arg(name='date', type=d.T.string)]),
          withDate(date): { expiration+: { date: date } },
          '#withDays':: d.fn(help='', args=[d.arg(name='days', type=d.T.integer)]),
          withDays(days): { expiration+: { days: days } },
          '#withExpiredObjectDeleteMarker':: d.fn(help='', args=[d.arg(name='expiredObjectDeleteMarker', type=d.T.boolean)]),
          withExpiredObjectDeleteMarker(expiredObjectDeleteMarker): { expiration+: { expiredObjectDeleteMarker: expiredObjectDeleteMarker } },
        },
        '#filter':: d.obj(help='"The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified."'),
        filter: {
          '#and':: d.obj(help='"This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator."'),
          and: {
            '#tags':: d.obj(help=''),
            tags: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withObjectSizeGreaterThan':: d.fn(help='', args=[d.arg(name='objectSizeGreaterThan', type=d.T.integer)]),
            withObjectSizeGreaterThan(objectSizeGreaterThan): { filter+: { and+: { objectSizeGreaterThan: objectSizeGreaterThan } } },
            '#withObjectSizeLessThan':: d.fn(help='', args=[d.arg(name='objectSizeLessThan', type=d.T.integer)]),
            withObjectSizeLessThan(objectSizeLessThan): { filter+: { and+: { objectSizeLessThan: objectSizeLessThan } } },
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { filter+: { and+: { prefix: prefix } } },
            '#withTags':: d.fn(help='', args=[d.arg(name='tags', type=d.T.array)]),
            withTags(tags): { filter+: { and+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
            '#withTagsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
            withTagsMixin(tags): { filter+: { and+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
          },
          '#tag':: d.obj(help='"A container of a key value name pair."'),
          tag: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { filter+: { tag+: { key: key } } },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { filter+: { tag+: { value: value } } },
          },
          '#withObjectSizeGreaterThan':: d.fn(help='', args=[d.arg(name='objectSizeGreaterThan', type=d.T.integer)]),
          withObjectSizeGreaterThan(objectSizeGreaterThan): { filter+: { objectSizeGreaterThan: objectSizeGreaterThan } },
          '#withObjectSizeLessThan':: d.fn(help='', args=[d.arg(name='objectSizeLessThan', type=d.T.integer)]),
          withObjectSizeLessThan(objectSizeLessThan): { filter+: { objectSizeLessThan: objectSizeLessThan } },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { filter+: { prefix: prefix } },
        },
        '#noncurrentVersionExpiration':: d.obj(help="\"Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.\""),
        noncurrentVersionExpiration: {
          '#withNewerNoncurrentVersions':: d.fn(help='', args=[d.arg(name='newerNoncurrentVersions', type=d.T.integer)]),
          withNewerNoncurrentVersions(newerNoncurrentVersions): { noncurrentVersionExpiration+: { newerNoncurrentVersions: newerNoncurrentVersions } },
          '#withNoncurrentDays':: d.fn(help='', args=[d.arg(name='noncurrentDays', type=d.T.integer)]),
          withNoncurrentDays(noncurrentDays): { noncurrentVersionExpiration+: { noncurrentDays: noncurrentDays } },
        },
        '#noncurrentVersionTransitions':: d.obj(help=''),
        noncurrentVersionTransitions: {
          '#withNewerNoncurrentVersions':: d.fn(help='', args=[d.arg(name='newerNoncurrentVersions', type=d.T.integer)]),
          withNewerNoncurrentVersions(newerNoncurrentVersions): { newerNoncurrentVersions: newerNoncurrentVersions },
          '#withNoncurrentDays':: d.fn(help='', args=[d.arg(name='noncurrentDays', type=d.T.integer)]),
          withNoncurrentDays(noncurrentDays): { noncurrentDays: noncurrentDays },
          '#withStorageClass':: d.fn(help='', args=[d.arg(name='storageClass', type=d.T.string)]),
          withStorageClass(storageClass): { storageClass: storageClass },
        },
        '#transitions':: d.obj(help=''),
        transitions: {
          '#withDate':: d.fn(help='', args=[d.arg(name='date', type=d.T.string)]),
          withDate(date): { date: date },
          '#withDays':: d.fn(help='', args=[d.arg(name='days', type=d.T.integer)]),
          withDays(days): { days: days },
          '#withStorageClass':: d.fn(help='', args=[d.arg(name='storageClass', type=d.T.string)]),
          withStorageClass(storageClass): { storageClass: storageClass },
        },
        '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withNoncurrentVersionTransitions':: d.fn(help='', args=[d.arg(name='noncurrentVersionTransitions', type=d.T.array)]),
        withNoncurrentVersionTransitions(noncurrentVersionTransitions): { noncurrentVersionTransitions: if std.isArray(v=noncurrentVersionTransitions) then noncurrentVersionTransitions else [noncurrentVersionTransitions] },
        '#withNoncurrentVersionTransitionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noncurrentVersionTransitions', type=d.T.array)]),
        withNoncurrentVersionTransitionsMixin(noncurrentVersionTransitions): { noncurrentVersionTransitions+: if std.isArray(v=noncurrentVersionTransitions) then noncurrentVersionTransitions else [noncurrentVersionTransitions] },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { prefix: prefix },
        '#withTransitions':: d.fn(help='', args=[d.arg(name='transitions', type=d.T.array)]),
        withTransitions(transitions): { transitions: if std.isArray(v=transitions) then transitions else [transitions] },
        '#withTransitionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='transitions', type=d.T.array)]),
        withTransitionsMixin(transitions): { transitions+: if std.isArray(v=transitions) then transitions else [transitions] },
      },
      '#withRules':: d.fn(help='', args=[d.arg(name='rules', type=d.T.array)]),
      withRules(rules): { spec+: { lifecycle+: { rules: if std.isArray(v=rules) then rules else [rules] } } },
      '#withRulesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rules', type=d.T.array)]),
      withRulesMixin(rules): { spec+: { lifecycle+: { rules+: if std.isArray(v=rules) then rules else [rules] } } },
    },
    '#logging':: d.obj(help='"Container for logging status information."'),
    logging: {
      '#loggingEnabled':: d.obj(help='"Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For more information, see PUT Bucket logging (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the Amazon S3 API Reference."'),
      loggingEnabled: {
        '#targetGrants':: d.obj(help=''),
        targetGrants: {
          '#grantee':: d.obj(help='"Container for the person being granted permissions."'),
          grantee: {
            '#withDisplayName':: d.fn(help='', args=[d.arg(name='displayName', type=d.T.string)]),
            withDisplayName(displayName): { grantee+: { displayName: displayName } },
            '#withEmailAddress':: d.fn(help='', args=[d.arg(name='emailAddress', type=d.T.string)]),
            withEmailAddress(emailAddress): { grantee+: { emailAddress: emailAddress } },
            '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
            withId(id): { grantee+: { id: id } },
            '#withType_':: d.fn(help='', args=[d.arg(name='type_', type=d.T.string)]),
            withType_(type_): { grantee+: { type_: type_ } },
            '#withURI':: d.fn(help='', args=[d.arg(name='uRI', type=d.T.string)]),
            withURI(uRI): { grantee+: { uRI: uRI } },
          },
          '#withPermission':: d.fn(help='', args=[d.arg(name='permission', type=d.T.string)]),
          withPermission(permission): { permission: permission },
        },
        '#withTargetBucket':: d.fn(help='', args=[d.arg(name='targetBucket', type=d.T.string)]),
        withTargetBucket(targetBucket): { spec+: { logging+: { loggingEnabled+: { targetBucket: targetBucket } } } },
        '#withTargetGrants':: d.fn(help='', args=[d.arg(name='targetGrants', type=d.T.array)]),
        withTargetGrants(targetGrants): { spec+: { logging+: { loggingEnabled+: { targetGrants: if std.isArray(v=targetGrants) then targetGrants else [targetGrants] } } } },
        '#withTargetGrantsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetGrants', type=d.T.array)]),
        withTargetGrantsMixin(targetGrants): { spec+: { logging+: { loggingEnabled+: { targetGrants+: if std.isArray(v=targetGrants) then targetGrants else [targetGrants] } } } },
        '#withTargetPrefix':: d.fn(help='', args=[d.arg(name='targetPrefix', type=d.T.string)]),
        withTargetPrefix(targetPrefix): { spec+: { logging+: { loggingEnabled+: { targetPrefix: targetPrefix } } } },
      },
    },
    '#metrics':: d.obj(help=''),
    metrics: {
      '#filter':: d.obj(help="\"Specifies a metrics configuration filter. The metrics configuration only includes objects that meet the filter's criteria. A filter must be a prefix, an object tag, an access point ARN, or a conjunction (MetricsAndOperator). For more information, see PutBucketMetricsConfiguration (https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketMetricsConfiguration.html).\""),
      filter: {
        '#and':: d.obj(help='"A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply."'),
        and: {
          '#tags':: d.obj(help=''),
          tags: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withAccessPointARN':: d.fn(help='', args=[d.arg(name='accessPointARN', type=d.T.string)]),
          withAccessPointARN(accessPointARN): { filter+: { and+: { accessPointARN: accessPointARN } } },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { filter+: { and+: { prefix: prefix } } },
          '#withTags':: d.fn(help='', args=[d.arg(name='tags', type=d.T.array)]),
          withTags(tags): { filter+: { and+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
          '#withTagsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
          withTagsMixin(tags): { filter+: { and+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
        },
        '#tag':: d.obj(help='"A container of a key value name pair."'),
        tag: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { filter+: { tag+: { key: key } } },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { filter+: { tag+: { value: value } } },
        },
        '#withAccessPointARN':: d.fn(help='', args=[d.arg(name='accessPointARN', type=d.T.string)]),
        withAccessPointARN(accessPointARN): { filter+: { accessPointARN: accessPointARN } },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { filter+: { prefix: prefix } },
      },
      '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
      withId(id): { id: id },
    },
    '#notification':: d.obj(help='"A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket."'),
    notification: {
      '#lambdaFunctionConfigurations':: d.obj(help=''),
      lambdaFunctionConfigurations: {
        '#filter':: d.obj(help='"Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide."'),
        filter: {
          '#key':: d.obj(help='"A container for object key name prefix and suffix filtering rules."'),
          key: {
            '#filterRules':: d.obj(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."'),
            filterRules: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withFilterRules':: d.fn(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."', args=[d.arg(name='filterRules', type=d.T.array)]),
            withFilterRules(filterRules): { filter+: { key+: { filterRules: if std.isArray(v=filterRules) then filterRules else [filterRules] } } },
            '#withFilterRulesMixin':: d.fn(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='filterRules', type=d.T.array)]),
            withFilterRulesMixin(filterRules): { filter+: { key+: { filterRules+: if std.isArray(v=filterRules) then filterRules else [filterRules] } } },
          },
        },
        '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
        withEvents(events): { events: if std.isArray(v=events) then events else [events] },
        '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
        withEventsMixin(events): { events+: if std.isArray(v=events) then events else [events] },
        '#withId':: d.fn(help="\"An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.\"", args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withLambdaFunctionARN':: d.fn(help='', args=[d.arg(name='lambdaFunctionARN', type=d.T.string)]),
        withLambdaFunctionARN(lambdaFunctionARN): { lambdaFunctionARN: lambdaFunctionARN },
      },
      '#queueConfigurations':: d.obj(help=''),
      queueConfigurations: {
        '#filter':: d.obj(help='"Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide."'),
        filter: {
          '#key':: d.obj(help='"A container for object key name prefix and suffix filtering rules."'),
          key: {
            '#filterRules':: d.obj(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."'),
            filterRules: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withFilterRules':: d.fn(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."', args=[d.arg(name='filterRules', type=d.T.array)]),
            withFilterRules(filterRules): { filter+: { key+: { filterRules: if std.isArray(v=filterRules) then filterRules else [filterRules] } } },
            '#withFilterRulesMixin':: d.fn(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='filterRules', type=d.T.array)]),
            withFilterRulesMixin(filterRules): { filter+: { key+: { filterRules+: if std.isArray(v=filterRules) then filterRules else [filterRules] } } },
          },
        },
        '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
        withEvents(events): { events: if std.isArray(v=events) then events else [events] },
        '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
        withEventsMixin(events): { events+: if std.isArray(v=events) then events else [events] },
        '#withId':: d.fn(help="\"An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.\"", args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withQueueARN':: d.fn(help='', args=[d.arg(name='queueARN', type=d.T.string)]),
        withQueueARN(queueARN): { queueARN: queueARN },
      },
      '#topicConfigurations':: d.obj(help=''),
      topicConfigurations: {
        '#filter':: d.obj(help='"Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide."'),
        filter: {
          '#key':: d.obj(help='"A container for object key name prefix and suffix filtering rules."'),
          key: {
            '#filterRules':: d.obj(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."'),
            filterRules: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withFilterRules':: d.fn(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."', args=[d.arg(name='filterRules', type=d.T.array)]),
            withFilterRules(filterRules): { filter+: { key+: { filterRules: if std.isArray(v=filterRules) then filterRules else [filterRules] } } },
            '#withFilterRulesMixin':: d.fn(help='"A list of containers for the key-value pair that defines the criteria for the filter rule."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='filterRules', type=d.T.array)]),
            withFilterRulesMixin(filterRules): { filter+: { key+: { filterRules+: if std.isArray(v=filterRules) then filterRules else [filterRules] } } },
          },
        },
        '#withEvents':: d.fn(help='', args=[d.arg(name='events', type=d.T.array)]),
        withEvents(events): { events: if std.isArray(v=events) then events else [events] },
        '#withEventsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
        withEventsMixin(events): { events+: if std.isArray(v=events) then events else [events] },
        '#withId':: d.fn(help="\"An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.\"", args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withTopicARN':: d.fn(help='', args=[d.arg(name='topicARN', type=d.T.string)]),
        withTopicARN(topicARN): { topicARN: topicARN },
      },
      '#withLambdaFunctionConfigurations':: d.fn(help='', args=[d.arg(name='lambdaFunctionConfigurations', type=d.T.array)]),
      withLambdaFunctionConfigurations(lambdaFunctionConfigurations): { spec+: { notification+: { lambdaFunctionConfigurations: if std.isArray(v=lambdaFunctionConfigurations) then lambdaFunctionConfigurations else [lambdaFunctionConfigurations] } } },
      '#withLambdaFunctionConfigurationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lambdaFunctionConfigurations', type=d.T.array)]),
      withLambdaFunctionConfigurationsMixin(lambdaFunctionConfigurations): { spec+: { notification+: { lambdaFunctionConfigurations+: if std.isArray(v=lambdaFunctionConfigurations) then lambdaFunctionConfigurations else [lambdaFunctionConfigurations] } } },
      '#withQueueConfigurations':: d.fn(help='', args=[d.arg(name='queueConfigurations', type=d.T.array)]),
      withQueueConfigurations(queueConfigurations): { spec+: { notification+: { queueConfigurations: if std.isArray(v=queueConfigurations) then queueConfigurations else [queueConfigurations] } } },
      '#withQueueConfigurationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='queueConfigurations', type=d.T.array)]),
      withQueueConfigurationsMixin(queueConfigurations): { spec+: { notification+: { queueConfigurations+: if std.isArray(v=queueConfigurations) then queueConfigurations else [queueConfigurations] } } },
      '#withTopicConfigurations':: d.fn(help='', args=[d.arg(name='topicConfigurations', type=d.T.array)]),
      withTopicConfigurations(topicConfigurations): { spec+: { notification+: { topicConfigurations: if std.isArray(v=topicConfigurations) then topicConfigurations else [topicConfigurations] } } },
      '#withTopicConfigurationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='topicConfigurations', type=d.T.array)]),
      withTopicConfigurationsMixin(topicConfigurations): { spec+: { notification+: { topicConfigurations+: if std.isArray(v=topicConfigurations) then topicConfigurations else [topicConfigurations] } } },
    },
    '#ownershipControls':: d.obj(help='"The OwnershipControls (BucketOwnerEnforced, BucketOwnerPreferred, or ObjectWriter) that you want to apply to this Amazon S3 bucket."'),
    ownershipControls: {
      '#rules':: d.obj(help=''),
      rules: {
        '#withObjectOwnership':: d.fn(help="\"The container element for object ownership for a bucket's ownership controls. \\n BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL. \\n ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL. \\n BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer affect permissions. The bucket owner automatically owns and has full control over every object in the bucket. The bucket only accepts PUT requests that don't specify an ACL or bucket owner full control ACLs, such as the bucket-owner-full-control canned ACL or an equivalent form of this ACL expressed in the XML format.\"", args=[d.arg(name='objectOwnership', type=d.T.string)]),
        withObjectOwnership(objectOwnership): { objectOwnership: objectOwnership },
      },
      '#withRules':: d.fn(help='', args=[d.arg(name='rules', type=d.T.array)]),
      withRules(rules): { spec+: { ownershipControls+: { rules: if std.isArray(v=rules) then rules else [rules] } } },
      '#withRulesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rules', type=d.T.array)]),
      withRulesMixin(rules): { spec+: { ownershipControls+: { rules+: if std.isArray(v=rules) then rules else [rules] } } },
    },
    '#publicAccessBlock':: d.obj(help='"The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see The Meaning of \\"Public\\" (https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide."'),
    publicAccessBlock: {
      '#withBlockPublicACLs':: d.fn(help='', args=[d.arg(name='blockPublicACLs', type=d.T.boolean)]),
      withBlockPublicACLs(blockPublicACLs): { spec+: { publicAccessBlock+: { blockPublicACLs: blockPublicACLs } } },
      '#withBlockPublicPolicy':: d.fn(help='', args=[d.arg(name='blockPublicPolicy', type=d.T.boolean)]),
      withBlockPublicPolicy(blockPublicPolicy): { spec+: { publicAccessBlock+: { blockPublicPolicy: blockPublicPolicy } } },
      '#withIgnorePublicACLs':: d.fn(help='', args=[d.arg(name='ignorePublicACLs', type=d.T.boolean)]),
      withIgnorePublicACLs(ignorePublicACLs): { spec+: { publicAccessBlock+: { ignorePublicACLs: ignorePublicACLs } } },
      '#withRestrictPublicBuckets':: d.fn(help='', args=[d.arg(name='restrictPublicBuckets', type=d.T.boolean)]),
      withRestrictPublicBuckets(restrictPublicBuckets): { spec+: { publicAccessBlock+: { restrictPublicBuckets: restrictPublicBuckets } } },
    },
    '#replication':: d.obj(help='"A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB."'),
    replication: {
      '#rules':: d.obj(help=''),
      rules: {
        '#deleteMarkerReplication':: d.obj(help='"Specifies whether Amazon S3 replicates delete markers. If you specify a Filter in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication Status must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config). \\n For more information about delete marker replication, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html). \\n If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see Backward Compatibility (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations)."'),
        deleteMarkerReplication: {},
        '#destination':: d.obj(help='"Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC)."'),
        destination: {
          '#accessControlTranslation':: d.obj(help='"A container for information about access control for replicas."'),
          accessControlTranslation: {
            '#withOwner':: d.fn(help='', args=[d.arg(name='owner', type=d.T.string)]),
            withOwner(owner): { destination+: { accessControlTranslation+: { owner: owner } } },
          },
          '#encryptionConfiguration':: d.obj(help='"Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects."'),
          encryptionConfiguration: {
            '#withReplicaKMSKeyID':: d.fn(help='', args=[d.arg(name='replicaKMSKeyID', type=d.T.string)]),
            withReplicaKMSKeyID(replicaKMSKeyID): { destination+: { encryptionConfiguration+: { replicaKMSKeyID: replicaKMSKeyID } } },
          },
          '#metrics':: d.obj(help='"A container specifying replication metrics-related settings enabling replication metrics and events."'),
          metrics: {
            '#eventThreshold':: d.obj(help='"A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold."'),
            eventThreshold: {
              '#withMinutes':: d.fn(help='', args=[d.arg(name='minutes', type=d.T.integer)]),
              withMinutes(minutes): { destination+: { metrics+: { eventThreshold+: { minutes: minutes } } } },
            },
          },
          '#replicationTime':: d.obj(help='"A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block."'),
          replicationTime: {
            '#time':: d.obj(help='"A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold."'),
            time: {
              '#withMinutes':: d.fn(help='', args=[d.arg(name='minutes', type=d.T.integer)]),
              withMinutes(minutes): { destination+: { replicationTime+: { time+: { minutes: minutes } } } },
            },
          },
          '#withAccount':: d.fn(help='', args=[d.arg(name='account', type=d.T.string)]),
          withAccount(account): { destination+: { account: account } },
          '#withBucket':: d.fn(help='', args=[d.arg(name='bucket', type=d.T.string)]),
          withBucket(bucket): { destination+: { bucket: bucket } },
          '#withStorageClass':: d.fn(help='', args=[d.arg(name='storageClass', type=d.T.string)]),
          withStorageClass(storageClass): { destination+: { storageClass: storageClass } },
        },
        '#existingObjectReplication':: d.obj(help='"Optional configuration to replicate existing source bucket objects. For more information, see Replicating Existing Objects (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication) in the Amazon S3 User Guide."'),
        existingObjectReplication: {},
        '#filter':: d.obj(help='"A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element."'),
        filter: {
          '#and':: d.obj(help='"A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. \\n For example: \\n * If you specify both a Prefix and a Tag filter, wrap these filters in an And tag. \\n * If you specify a filter based on multiple tags, wrap the Tag elements in an And tag."'),
          and: {
            '#tags':: d.obj(help=''),
            tags: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { filter+: { and+: { prefix: prefix } } },
            '#withTags':: d.fn(help='', args=[d.arg(name='tags', type=d.T.array)]),
            withTags(tags): { filter+: { and+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
            '#withTagsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
            withTagsMixin(tags): { filter+: { and+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
          },
          '#tag':: d.obj(help='"A container of a key value name pair."'),
          tag: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { filter+: { tag+: { key: key } } },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { filter+: { tag+: { value: value } } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { filter+: { prefix: prefix } },
        },
        '#sourceSelectionCriteria':: d.obj(help='"A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer managed key stored in Amazon Web Services Key Management Service (SSE-KMS)."'),
        sourceSelectionCriteria: {
          '#replicaModifications':: d.obj(help="\"A filter that you can specify for selection for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when Filter is specified), you can specify this element and set the status to Enabled to replicate modifications on replicas. \\n If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, this element is not allowed.\""),
          replicaModifications: {},
          '#sseKMSEncryptedObjects':: d.obj(help='"A container for filter information for the selection of S3 objects encrypted with Amazon Web Services KMS."'),
          sseKMSEncryptedObjects: {},
        },
        '#withId':: d.fn(help='', args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { prefix: prefix },
        '#withPriority':: d.fn(help='', args=[d.arg(name='priority', type=d.T.integer)]),
        withPriority(priority): { priority: priority },
      },
      '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
      withRole(role): { spec+: { replication+: { role: role } } },
      '#withRules':: d.fn(help='', args=[d.arg(name='rules', type=d.T.array)]),
      withRules(rules): { spec+: { replication+: { rules: if std.isArray(v=rules) then rules else [rules] } } },
      '#withRulesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rules', type=d.T.array)]),
      withRulesMixin(rules): { spec+: { replication+: { rules+: if std.isArray(v=rules) then rules else [rules] } } },
    },
    '#requestPayment':: d.obj(help='"Container for Payer."'),
    requestPayment: {
      '#withPayer':: d.fn(help='', args=[d.arg(name='payer', type=d.T.string)]),
      withPayer(payer): { spec+: { requestPayment+: { payer: payer } } },
    },
    '#tagging':: d.obj(help='"Container for the TagSet and Tag elements."'),
    tagging: {
      '#tagSet':: d.obj(help=''),
      tagSet: {
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#withTagSet':: d.fn(help='', args=[d.arg(name='tagSet', type=d.T.array)]),
      withTagSet(tagSet): { spec+: { tagging+: { tagSet: if std.isArray(v=tagSet) then tagSet else [tagSet] } } },
      '#withTagSetMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tagSet', type=d.T.array)]),
      withTagSetMixin(tagSet): { spec+: { tagging+: { tagSet+: if std.isArray(v=tagSet) then tagSet else [tagSet] } } },
    },
    '#versioning':: d.obj(help='"Container for setting the versioning state."'),
    versioning: {},
    '#website':: d.obj(help='"Container for the request."'),
    website: {
      '#errorDocument':: d.obj(help='"The error information."'),
      errorDocument: {
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { spec+: { website+: { errorDocument+: { key: key } } } },
      },
      '#indexDocument':: d.obj(help='"Container for the Suffix element."'),
      indexDocument: {
        '#withSuffix':: d.fn(help='', args=[d.arg(name='suffix', type=d.T.string)]),
        withSuffix(suffix): { spec+: { website+: { indexDocument+: { suffix: suffix } } } },
      },
      '#redirectAllRequestsTo':: d.obj(help='"Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket."'),
      redirectAllRequestsTo: {
        '#withHostName':: d.fn(help='', args=[d.arg(name='hostName', type=d.T.string)]),
        withHostName(hostName): { spec+: { website+: { redirectAllRequestsTo+: { hostName: hostName } } } },
        '#withProtocol':: d.fn(help='', args=[d.arg(name='protocol', type=d.T.string)]),
        withProtocol(protocol): { spec+: { website+: { redirectAllRequestsTo+: { protocol: protocol } } } },
      },
      '#routingRules':: d.obj(help=''),
      routingRules: {
        '#condition':: d.obj(help='"A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error."'),
        condition: {
          '#withHttpErrorCodeReturnedEquals':: d.fn(help='', args=[d.arg(name='httpErrorCodeReturnedEquals', type=d.T.string)]),
          withHttpErrorCodeReturnedEquals(httpErrorCodeReturnedEquals): { condition+: { httpErrorCodeReturnedEquals: httpErrorCodeReturnedEquals } },
          '#withKeyPrefixEquals':: d.fn(help='', args=[d.arg(name='keyPrefixEquals', type=d.T.string)]),
          withKeyPrefixEquals(keyPrefixEquals): { condition+: { keyPrefixEquals: keyPrefixEquals } },
        },
        '#redirect':: d.obj(help='"Specifies how requests are redirected. In the event of an error, you can specify a different error code to return."'),
        redirect: {
          '#withHostName':: d.fn(help='', args=[d.arg(name='hostName', type=d.T.string)]),
          withHostName(hostName): { redirect+: { hostName: hostName } },
          '#withHttpRedirectCode':: d.fn(help='', args=[d.arg(name='httpRedirectCode', type=d.T.string)]),
          withHttpRedirectCode(httpRedirectCode): { redirect+: { httpRedirectCode: httpRedirectCode } },
          '#withProtocol':: d.fn(help='', args=[d.arg(name='protocol', type=d.T.string)]),
          withProtocol(protocol): { redirect+: { protocol: protocol } },
          '#withReplaceKeyPrefixWith':: d.fn(help='', args=[d.arg(name='replaceKeyPrefixWith', type=d.T.string)]),
          withReplaceKeyPrefixWith(replaceKeyPrefixWith): { redirect+: { replaceKeyPrefixWith: replaceKeyPrefixWith } },
          '#withReplaceKeyWith':: d.fn(help='', args=[d.arg(name='replaceKeyWith', type=d.T.string)]),
          withReplaceKeyWith(replaceKeyWith): { redirect+: { replaceKeyWith: replaceKeyWith } },
        },
      },
      '#withRoutingRules':: d.fn(help='', args=[d.arg(name='routingRules', type=d.T.array)]),
      withRoutingRules(routingRules): { spec+: { website+: { routingRules: if std.isArray(v=routingRules) then routingRules else [routingRules] } } },
      '#withRoutingRulesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='routingRules', type=d.T.array)]),
      withRoutingRulesMixin(routingRules): { spec+: { website+: { routingRules+: if std.isArray(v=routingRules) then routingRules else [routingRules] } } },
    },
    '#withAcl':: d.fn(help='"The canned ACL to apply to the bucket."', args=[d.arg(name='acl', type=d.T.string)]),
    withAcl(acl): { spec+: { acl: acl } },
    '#withAnalytics':: d.fn(help='', args=[d.arg(name='analytics', type=d.T.array)]),
    withAnalytics(analytics): { spec+: { analytics: if std.isArray(v=analytics) then analytics else [analytics] } },
    '#withAnalyticsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='analytics', type=d.T.array)]),
    withAnalyticsMixin(analytics): { spec+: { analytics+: if std.isArray(v=analytics) then analytics else [analytics] } },
    '#withGrantFullControl':: d.fn(help='"Allows grantee the read, write, read ACP, and write ACP permissions on the bucket."', args=[d.arg(name='grantFullControl', type=d.T.string)]),
    withGrantFullControl(grantFullControl): { spec+: { grantFullControl: grantFullControl } },
    '#withGrantRead':: d.fn(help='"Allows grantee to list the objects in the bucket."', args=[d.arg(name='grantRead', type=d.T.string)]),
    withGrantRead(grantRead): { spec+: { grantRead: grantRead } },
    '#withGrantReadACP':: d.fn(help='"Allows grantee to read the bucket ACL."', args=[d.arg(name='grantReadACP', type=d.T.string)]),
    withGrantReadACP(grantReadACP): { spec+: { grantReadACP: grantReadACP } },
    '#withGrantWrite':: d.fn(help='"Allows grantee to create new objects in the bucket. \\n For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects."', args=[d.arg(name='grantWrite', type=d.T.string)]),
    withGrantWrite(grantWrite): { spec+: { grantWrite: grantWrite } },
    '#withGrantWriteACP':: d.fn(help='"Allows grantee to write the ACL for the applicable bucket."', args=[d.arg(name='grantWriteACP', type=d.T.string)]),
    withGrantWriteACP(grantWriteACP): { spec+: { grantWriteACP: grantWriteACP } },
    '#withIntelligentTiering':: d.fn(help='', args=[d.arg(name='intelligentTiering', type=d.T.array)]),
    withIntelligentTiering(intelligentTiering): { spec+: { intelligentTiering: if std.isArray(v=intelligentTiering) then intelligentTiering else [intelligentTiering] } },
    '#withIntelligentTieringMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='intelligentTiering', type=d.T.array)]),
    withIntelligentTieringMixin(intelligentTiering): { spec+: { intelligentTiering+: if std.isArray(v=intelligentTiering) then intelligentTiering else [intelligentTiering] } },
    '#withInventory':: d.fn(help='', args=[d.arg(name='inventory', type=d.T.array)]),
    withInventory(inventory): { spec+: { inventory: if std.isArray(v=inventory) then inventory else [inventory] } },
    '#withInventoryMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inventory', type=d.T.array)]),
    withInventoryMixin(inventory): { spec+: { inventory+: if std.isArray(v=inventory) then inventory else [inventory] } },
    '#withMetrics':: d.fn(help='', args=[d.arg(name='metrics', type=d.T.array)]),
    withMetrics(metrics): { spec+: { metrics: if std.isArray(v=metrics) then metrics else [metrics] } },
    '#withMetricsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='metrics', type=d.T.array)]),
    withMetricsMixin(metrics): { spec+: { metrics+: if std.isArray(v=metrics) then metrics else [metrics] } },
    '#withName':: d.fn(help='"The name of the bucket to create."', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { spec+: { name: name } },
    '#withObjectLockEnabledForBucket':: d.fn(help='"Specifies whether you want S3 Object Lock to be enabled for the new bucket."', args=[d.arg(name='objectLockEnabledForBucket', type=d.T.boolean)]),
    withObjectLockEnabledForBucket(objectLockEnabledForBucket): { spec+: { objectLockEnabledForBucket: objectLockEnabledForBucket } },
    '#withObjectOwnership':: d.fn(help='', args=[d.arg(name='objectOwnership', type=d.T.string)]),
    withObjectOwnership(objectOwnership): { spec+: { objectOwnership: objectOwnership } },
    '#withPolicy':: d.fn(help='"The bucket policy as a JSON document."', args=[d.arg(name='policy', type=d.T.string)]),
    withPolicy(policy): { spec+: { policy: policy } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
